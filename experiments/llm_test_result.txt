/opt/miniconda/envs/langchain-env/bin/python /opt/pycharm-professional/plugins/python-ce/helpers/pycharm/_jb_unittest_runner.py --target test1.Test1.test_1 
Testing started at 23:13 ...
Launching unittests with arguments python -m unittest test1.Test1.test_1 in /home/ran/Documents/work/graduate/BenchmarkJava/annotated-benchmark/semantic-restoration/src/llm/test

2025-03-25 23:13:02,950 - data_processor - INFO - 初始化数据处理器: 项目目录=/home/ran/Documents/work/graduate/BenchmarkJava/annotated-benchmark, 建模目录=/home/ran/Documents/work/graduate/BenchmarkJava/annotated-benchmark/semantic-restoration/experiments
2025-03-25 23:13:02,950 - data_processor - INFO - 开始加载建模数据...
2025-03-25 23:13:02,951 - data_processor - INFO - 已加载AOP数据: 6 条记录
2025-03-25 23:13:02,951 - data_processor - INFO - 已加载IoC数据: 36 条记录
2025-03-25 23:13:02,951 - data_processor - INFO - 已加载字段定义: 108 条记录
2025-03-25 23:13:02,952 - data_processor - INFO - 已加载字段引用: 108 条记录
2025-03-25 23:13:02,953 - data_processor - INFO - 已加载方法定义: 319 条记录
2025-03-25 23:13:02,954 - data_processor - INFO - 已加载方法调用: 140 条记录
2025-03-25 23:13:02,954 - data_processor - INFO - 已加载调用图: 308 条记录
2025-03-25 23:13:02,955 - data_processor - INFO - 开始扫描Java文件...
['semantic-restoration/src/main/java/edu/thu/soot/CallGraphGenerator.java', 'semantic-restoration/src/main/java/edu/thu/soot/FieldLineNumberFinder.java', 'semantic-restoration/src/main/java/edu/thu/soot/FieldLineNumberVisitor.java', 'semantic-restoration/src/main/java/edu/thu/soot/JimpleGenerator.java', 'semantic-restoration/src/main/java/edu/thu/soot/SootCodeAnalyzer.java', 'semantic-restoration/src/test/java/Test1.java', 'src/main/java/edu/thu/benchmark/annotated/AnnotatedBenchmarkApplication.java', 'src/main/java/edu/thu/benchmark/annotated/annotation/Vulnerability.java', 'src/main/java/edu/thu/benchmark/annotated/annotation/VulnerabilityLevel.java', 'src/main/java/edu/thu/benchmark/annotated/annotation/VulnerabilityType.java', 'src/main/java/edu/thu/benchmark/annotated/aspect/CommandExecutionAspect.java', 'src/main/java/edu/thu/benchmark/annotated/aspect/CustomSqlExecution.java', 'src/main/java/edu/thu/benchmark/annotated/aspect/FileAccessAspect.java', 'src/main/java/edu/thu/benchmark/annotated/aspect/FileAccessAspect1.java', 'src/main/java/edu/thu/benchmark/annotated/aspect/SqlInjectionAspect.java', 'src/main/java/edu/thu/benchmark/annotated/config/AppConfig.java', 'src/main/java/edu/thu/benchmark/annotated/config/DatabaseConfig.java', 'src/main/java/edu/thu/benchmark/annotated/config/WebMvcConfig.java', 'src/main/java/edu/thu/benchmark/annotated/controller/CommandController.java', 'src/main/java/edu/thu/benchmark/annotated/controller/CommandInjectionController.java', 'src/main/java/edu/thu/benchmark/annotated/controller/FileController.java', 'src/main/java/edu/thu/benchmark/annotated/controller/HomeController.java', 'src/main/java/edu/thu/benchmark/annotated/controller/HttpController.java', 'src/main/java/edu/thu/benchmark/annotated/controller/PathTraversalController.java', 'src/main/java/edu/thu/benchmark/annotated/controller/SqlInjectionTestController.java', 'src/main/java/edu/thu/benchmark/annotated/controller/UserController.java', 'src/main/java/edu/thu/benchmark/annotated/controller/XmlController.java', 'src/main/java/edu/thu/benchmark/annotated/entity/CommandExecution.java', 'src/main/java/edu/thu/benchmark/annotated/entity/FileInfo.java', 'src/main/java/edu/thu/benchmark/annotated/entity/Product.java', 'src/main/java/edu/thu/benchmark/annotated/entity/User.java', 'src/main/java/edu/thu/benchmark/annotated/mapper/UserMapper.java', 'src/main/java/edu/thu/benchmark/annotated/mapper/UserSqlInjectionMapper.java', 'src/main/java/edu/thu/benchmark/annotated/service/CommandService.java', 'src/main/java/edu/thu/benchmark/annotated/service/FileService.java', 'src/main/java/edu/thu/benchmark/annotated/service/FileUploadService.java', 'src/main/java/edu/thu/benchmark/annotated/service/PathTraversalService.java', 'src/main/java/edu/thu/benchmark/annotated/service/SqlInjectionTestService.java', 'src/main/java/edu/thu/benchmark/annotated/service/SqlInjectionTestService1.java', 'src/main/java/edu/thu/benchmark/annotated/service/TemplateService.java', 'src/main/java/edu/thu/benchmark/annotated/service/UserService.java', 'src/main/java/edu/thu/benchmark/annotated/service/ZipService.java', 'src/main/java/edu/thu/benchmark/annotated/service/impl/FileServiceImpl.java', 'src/main/java/edu/thu/benchmark/annotated/service/impl/UserServiceImpl.java', 'src/main/java/edu/thu/benchmark/annotated/util/CommandUtils.java', 'src/main/java/edu/thu/benchmark/annotated/util/FileUtils.java', 'src/main/java/edu/thu/benchmark/annotated/util/MyBatisCompiler.java', 'src/main/java/edu/thu/benchmark/annotated/util/MyBatisMapperScanner.java', 'src/main/java/edu/thu/benchmark/annotated/util/MyBatisSqlExtractor.java', 'src/main/java/edu/thu/benchmark/annotated/util/MyBatisXmlParser.java']

处理文件: semantic-restoration/src/main/java/edu/thu/soot/CallGraphGenerator.java

无需处理处理: semantic-restoration/src/main/java/edu/thu/soot/CallGraphGenerator.java. 跳过

处理文件: semantic-restoration/src/main/java/edu/thu/soot/FieldLineNumberFinder.java

无需处理处理: semantic-restoration/src/main/java/edu/thu/soot/FieldLineNumberFinder.java. 跳过

处理文件: semantic-restoration/src/main/java/edu/thu/soot/FieldLineNumberVisitor.java

无需处理处理: semantic-restoration/src/main/java/edu/thu/soot/FieldLineNumberVisitor.java. 跳过

处理文件: semantic-restoration/src/main/java/edu/thu/soot/JimpleGenerator.java

无需处理处理: semantic-restoration/src/main/java/edu/thu/soot/JimpleGenerator.java. 跳过

处理文件: semantic-restoration/src/main/java/edu/thu/soot/SootCodeAnalyzer.java

无需处理处理: semantic-restoration/src/main/java/edu/thu/soot/SootCodeAnalyzer.java. 跳过

处理文件: semantic-restoration/src/test/java/Test1.java

无需处理处理: semantic-restoration/src/test/java/Test1.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/AnnotatedBenchmarkApplication.java
2025-03-25 23:13:02,962 - data_processor - INFO - 共扫描到 50 个Java文件
2025-03-25 23:13:02,965 - data_processor - WARNING - 无法从文件 semantic-restoration/src/test/java/Test1.java 提取包名和类名

无需处理处理: src/main/java/edu/thu/benchmark/annotated/AnnotatedBenchmarkApplication.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/annotation/Vulnerability.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/annotation/Vulnerability.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/annotation/VulnerabilityLevel.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/annotation/VulnerabilityLevel.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/annotation/VulnerabilityType.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/annotation/VulnerabilityType.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/aspect/CommandExecutionAspect.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/aspect/CommandExecutionAspect.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/aspect/CustomSqlExecution.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/aspect/CustomSqlExecution.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/aspect/FileAccessAspect.java
2025-03-25 23:13:02,968 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742915584-HG75aoN39wjG83aphzv6', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915584, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.aspect;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * 文件访问切面\n * 用于拦截和记录文件访问操作\n */\n@Aspect\n@Component\npublic class FileAccessAspect {\n\n    // 原注解: @Value("${log.dir}")\n    private String logDir = "/tmp/logs";\n\n    /**\n     * 不安全的日志文件访问实现\n     * 在切面中直接使用用户提供的路径获取文件\n     *\n     * @param logFile 日志文件名\n     * @return 日志文件内容\n     */\n    public String accessLogFile(String logFile) {\n        try {\n            // 不安全：直接使用用户提供的日志文件路径\n            File file = new File(logFile);\n            return new String(Files.readAllBytes(file.toPath()));\n        } catch (IOException e) {\n            return "Error accessing log file: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 安全的日志文件访问实现\n     * 在切面中实现完整的路径验证逻辑\n     *\n     * @param logFile 日志文件名\n     * @return 日志文件内容\n     */\n    public String accessLogFileSafe(String logFile) {\n        try {\n            // 安全：规范化路径并验证\n            Path basePath = Paths.get(logDir).toAbsolutePath().normalize();\n            Path logPath = basePath.resolve(logFile).normalize();\n\n            // 验证最终路径是否在日志目录内\n            if (!logPath.startsWith(basePath)) {\n                throw new SecurityException("Access to the log file is not allowed");\n            }\n\n            if (!Files.isRegularFile(logPath)) {\n                throw new IOException("Log file not found or not a regular file");\n            }\n\n            return new String(Files.readAllBytes(logPath));\n        } catch (Exception e) {\n            return "Error accessing log file: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 记录不安全的文件访问操作\n     * 直接记录用户提供的路径而不验证\n     */\n    @Before("execution(* edu.thu.benchmark.annotated.controller.PathTraversalController.getFile*(..))") \n    public void logFileAccessUnsafe(JoinPoint joinPoint) {\n        try {\n            // 获取方法参数（文件路径）\n            Object[] args = joinPoint.getArgs();\n            if (args.length > 0 && args[0] instanceof String) {\n                String filePath = (String) args[0];\n                // 不安全：直接使用用户提供的路径构造日志文件路径\n                File logFile = new File(logDir, "file_access.log");\n                Files.write(logFile.toPath(),\n                        ("Accessed file: " + filePath + "\\n").getBytes(),\n                        java.nio.file.StandardOpenOption.CREATE,\n                        java.nio.file.StandardOpenOption.APPEND);\n            }\n        } catch (IOException e) {\n            // 记录错误但不中断执行\n            System.err.println("Error logging file access: " + e.getMessage());\n        }\n    }\n\n    /**\n     * 记录安全的文件访问操作\n     * 对用户提供的路径进行规范化和验证\n     */\n    @Before("execution(* edu.thu.benchmark.annotated.controller.PathTraversalController.getFile*Safe*(..))") \n    public void logFileAccessSafe(JoinPoint joinPoint) {\n        try {\n            // 获取方法参数（文件路径）\n            Object[] args = joinPoint.getArgs();\n            if (args.length > 0 && args[0] instanceof String) {\n                String filePath = (String) args[0];\n\n                // 安全：规范化并验证路径\n                String sanitizedPath = filePath.replaceAll("[^a-zA-Z0-9_.-]", "_");\n\n                // 构造安全的日志文件路径\n                Path logFilePath = Paths.get(logDir, "file_access_safe.log").normalize();\n\n                // 确保日志目录存在\n                Files.createDirectories(logFilePath.getParent());\n\n                // 记录访问信息\n                Files.write(logFilePath,\n                        ("Safely accessed file: " + sanitizedPath + "\\n").getBytes(),\n                        java.nio.file.StandardOpenOption.CREATE,\n                        java.nio.file.StandardOpenOption.APPEND);\n            }\n        } catch (IOException e) {\n            // 记录错误但不中断执行\n            System.err.println("Error safely logging file access: " + e.getMessage());\n        }\n    }\n\n    /**\n     * 不安全的文件操作前置通知\n     * 在特定操作前进行文件处理但不验证路径\n     */\n    @Before("execution(* edu.thu.benchmark.annotated.controller.PathTraversalController.getFileWithAspect*(..))") \n    public void beforeUnsafeFileAccess(JoinPoint joinPoint) {\n        try {\n            // 获取方法参数（文件路径）\n            Object[] args = joinPoint.getArgs();\n            if (args.length > 0 && args[0] instanceof String) {\n                String filePath = (String) args[0];\n                // 不安全：直接使用用户提供的路径\n                File file = new File(filePath);\n                if (file.exists()) {\n                    // 在访问前执行某些操作，但不验证路径安全性\n                    System.out.println("About to access file: " + file.getAbsolutePath());\n                }\n            }\n        } catch (Exception e) {\n            System.err.println("Error in file access aspect: " + e.getMessage());\n        }\n    }\n\n    /**\n     * 安全的文件操作前置通知\n     * 在特定操作前进行文件处理并验证路径\n     */\n    @Before("execution(* edu.thu.benchmark.annotated.controller.PathTraversalController.getFileWithAspectSafe*(..))") \n    public void beforeSafeFileAccess(JoinPoint joinPoint) {\n        try {\n            // 获取方法参数（文件路径）\n            Object[] args = joinPoint.getArgs();\n            if (args.length > 0 && args[0] instanceof String) {\n                String filePath = (String) args[0];\n\n                // 安全：规范化路径并验证\n                Path basePath = Paths.get(logDir).toAbsolutePath().normalize();\n                Path resolvedPath = basePath.resolve(filePath).normalize();\n\n                // 验证最终路径是否在允许的目录内\n                if (resolvedPath.startsWith(basePath) && Files.exists(resolvedPath)) {\n                    // 在访问前执行某些操作，并验证路径安全性\n                    System.out.println("About to safely access file: " + resolvedPath);\n                } else {\n                    throw new SecurityException("Access to the file is not allowed or file does not exist");\n                }\n            }\n        } catch (Exception e) {\n            System.err.println("Error in safe file access aspect: " + e.getMessage());\n        }\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 10854, 'completion_tokens': 2026, 'total_tokens': 12880}}
-----------

package edu.thu.benchmark.annotated.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * 文件访问切面
 * 用于拦截和记录文件访问操作
 */
@Aspect
@Component
public class FileAccessAspect {

    // 原注解: @Value("${log.dir}")
    private String logDir = "/tmp/logs";

    /**
     * 不安全的日志文件访问实现
     * 在切面中直接使用用户提供的路径获取文件
     *
     * @param logFile 日志文件名
     * @return 日志文件内容
     */
    public String accessLogFile(String logFile) {
        try {
            // 不安全：直接使用用户提供的日志文件路径
            File file = new File(logFile);
            return new String(Files.readAllBytes(file.toPath()));
        } catch (IOException e) {
            return "Error accessing log file: " + e.getMessage();
        }
    }

    /**
     * 安全的日志文件访问实现
     * 在切面中实现完整的路径验证逻辑
     *
     * @param logFile 日志文件名
     * @return 日志文件内容
     */
    public String accessLogFileSafe(String logFile) {
        try {
            // 安全：规范化路径并验证
            Path basePath = Paths.get(logDir).toAbsolutePath().normalize();
            Path logPath = basePath.resolve(logFile).normalize();

            // 验证最终路径是否在日志目录内
            if (!logPath.startsWith(basePath)) {
                throw new SecurityException("Access to the log file is not allowed");
            }

            if (!Files.isRegularFile(logPath)) {
                throw new IOException("Log file not found or not a regular file");
            }

            return new String(Files.readAllBytes(logPath));
        } catch (Exception e) {
            return "Error accessing log file: " + e.getMessage();
        }
    }

    /**
     * 记录不安全的文件访问操作
     * 直接记录用户提供的路径而不验证
     */
    @Before("execution(* edu.thu.benchmark.annotated.controller.PathTraversalController.getFile*(..))") 
    public void logFileAccessUnsafe(JoinPoint joinPoint) {
        try {
            // 获取方法参数（文件路径）
            Object[] args = joinPoint.getArgs();
            if (args.length > 0 && args[0] instanceof String) {
                String filePath = (String) args[0];
                // 不安全：直接使用用户提供的路径构造日志文件路径
                File logFile = new File(logDir, "file_access.log");
                Files.write(logFile.toPath(),
                        ("Accessed file: " + filePath + "\n").getBytes(),
                        java.nio.file.StandardOpenOption.CREATE,
                        java.nio.file.StandardOpenOption.APPEND);
            }
        } catch (IOException e) {
            // 记录错误但不中断执行
            System.err.println("Error logging file access: " + e.getMessage());
        }
    }

    /**
     * 记录安全的文件访问操作
     * 对用户提供的路径进行规范化和验证
     */
    @Before("execution(* edu.thu.benchmark.annotated.controller.PathTraversalController.getFile*Safe*(..))") 
    public void logFileAccessSafe(JoinPoint joinPoint) {
        try {
            // 获取方法参数（文件路径）
            Object[] args = joinPoint.getArgs();
            if (args.length > 0 && args[0] instanceof String) {
                String filePath = (String) args[0];

                // 安全：规范化并验证路径
                String sanitizedPath = filePath.replaceAll("[^a-zA-Z0-9_.-]", "_");

                // 构造安全的日志文件路径
                Path logFilePath = Paths.get(logDir, "file_access_safe.log").normalize();

                // 确保日志目录存在
                Files.createDirectories(logFilePath.getParent());

                // 记录访问信息
                Files.write(logFilePath,
                        ("Safely accessed file: " + sanitizedPath + "\n").getBytes(),
                        java.nio.file.StandardOpenOption.CREATE,
                        java.nio.file.StandardOpenOption.APPEND);
            }
        } catch (IOException e) {
            // 记录错误但不中断执行
            System.err.println("Error safely logging file access: " + e.getMessage());
        }
    }

    /**
     * 不安全的文件操作前置通知
     * 在特定操作前进行文件处理但不验证路径
     */
    @Before("execution(* edu.thu.benchmark.annotated.controller.PathTraversalController.getFileWithAspect*(..))") 
    public void beforeUnsafeFileAccess(JoinPoint joinPoint) {
        try {
            // 获取方法参数（文件路径）
            Object[] args = joinPoint.getArgs();
            if (args.length > 0 && args[0] instanceof String) {
                String filePath = (String) args[0];
                // 不安全：直接使用用户提供的路径
                File file = new File(filePath);
                if (file.exists()) {
                    // 在访问前执行某些操作，但不验证路径安全性
                    System.out.println("About to access file: " + file.getAbsolutePath());
                }
            }
        } catch (Exception e) {
            System.err.println("Error in file access aspect: " + e.getMessage());
        }
    }

    /**
     * 安全的文件操作前置通知
     * 在特定操作前进行文件处理并验证路径
     */
    @Before("execution(* edu.thu.benchmark.annotated.controller.PathTraversalController.getFileWithAspectSafe*(..))") 
    public void beforeSafeFileAccess(JoinPoint joinPoint) {
        try {
            // 获取方法参数（文件路径）
            Object[] args = joinPoint.getArgs();
            if (args.length > 0 && args[0] instanceof String) {
                String filePath = (String) args[0];

                // 安全：规范化路径并验证
                Path basePath = Paths.get(logDir).toAbsolutePath().normalize();
                Path resolvedPath = basePath.resolve(filePath).normalize();

                // 验证最终路径是否在允许的目录内
                if (resolvedPath.startsWith(basePath) && Files.exists(resolvedPath)) {
                    // 在访问前执行某些操作，并验证路径安全性
                    System.out.println("About to safely access file: " + resolvedPath);
                } else {
                    throw new SecurityException("Access to the file is not allowed or file does not exist");
                }
            }
        } catch (Exception e) {
            System.err.println("Error in safe file access aspect: " + e.getMessage());
        }
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/aspect/FileAccessAspect1.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/aspect/FileAccessAspect1.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/aspect/SqlInjectionAspect.java
2025-03-25 23:13:31,037 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742915638-HuyXbqemmUrWWK00axXx', 'provider': 'Anthropic', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915638, 'choices': []}
2025-03-25 23:13:59,509 - llm_client - WARNING - 请求失败 (尝试 1/3): 没有choice返回
2025-03-25 23:13:59,509 - llm_client - INFO - 等待 5 秒后重试...
{'id': 'gen-1742915645-Dh5e22tAny0yFmxk7Smo', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915645, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.aspect;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * SQL注入测试切面\n * 使用Before和After注解简化切面实现\n */\n@Aspect\n@Component\npublic class SqlInjectionAspect {\n\n    // 原注解: @Autowired\n    private JdbcTemplate jdbcTemplate = new JdbcTemplate();\n\n    /**\n     * 定义切入点：所有使用CustomSqlExecution注解的方法\n     */\n    @Pointcut("execution(* edu.thu.benchmark.annotated.service.SqlInjectionTestService.findUsersByAspectSafe(..))")\n    public void sqlInjectionServiceMethods() {\n    }\n\n    /**\n     * 在方法执行前执行不安全的SQL注入操作\n     */\n    @Before("sqlInjectionServiceMethods()")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在AOP切面中通过字符串拼接构造不安全的SQL查询",\n            remediation = "使用参数化查询替代字符串拼接",\n            level = VulnerabilityLevel.CRITICAL\n    )\n    public void beforeUnsafeSqlExecution() {\n        // 不安全的SQL查询示例\n        String username = "1; delete from users where id = 1";\n        String unsafeSql = "SELECT * FROM users WHERE username = \'" + username + "\'";\n        // 记录不安全的SQL注入操作\n        System.out.println("执行不安全的SQL查询: " + unsafeSql);\n\n    }\n\n    /**\n     * 在方法执行后执行安全的SQL查询操作\n     */\n    @After("sqlInjectionServiceMethods()")\n    public void afterSafeSqlExecution() {\n        // 安全的SQL查询示例\n\n        // 使用参数化查询\n        String safeSql = "SELECT * FROM users WHERE username = ran";\n        List<Map<String, Object>> result = jdbcTemplate.queryForList(safeSql);\n        // 记录安全的SQL查询操作\n        System.out.println("执行安全的SQL查询：参数化查询");\n\n    }\n\n    /**\n     * 针对findUsersByAspectUnsafe方法的特定切面\n     */\n    @Before("sqlInjectionServiceMethods()")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在Before切面中直接执行不安全的SQL查询",\n            remediation = "使用参数化查询替代字符串拼接",\n            level = VulnerabilityLevel.CRITICAL\n    )\n    public List<Map<String, Object>> executeUnsafeSql(String name) {\n        // 直接执行不安全的SQL查询\n        String username = "1; delete from users where id = 1";\n        String unsafeSql = "SELECT * FROM users WHERE username LIKE \'%" + username + "%\'";\n        return jdbcTemplate.queryForList(name);\n    }\n\n    /**\n     * 针对findUsersByAspectSafe方法的特定切面\n     */\n    @Before("sqlInjectionServiceMethods()")\n    public List<Map<String, Object>> executeSafeSql() {\n        // 执行安全的SQL查询\n        String username = "1";\n        String safeSql = "SELECT * FROM users WHERE username LIKE CONCAT(\'%\', ?, \'%\')";\n        return jdbcTemplate.queryForList(safeSql, username);\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 8893, 'completion_tokens': 1119, 'total_tokens': 10012}}
-----------

package edu.thu.benchmark.annotated.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

/**
 * SQL注入测试切面
 * 使用Before和After注解简化切面实现
 */
@Aspect
@Component
public class SqlInjectionAspect {

    // 原注解: @Autowired
    private JdbcTemplate jdbcTemplate = new JdbcTemplate();

    /**
     * 定义切入点：所有使用CustomSqlExecution注解的方法
     */
    @Pointcut("execution(* edu.thu.benchmark.annotated.service.SqlInjectionTestService.findUsersByAspectSafe(..))")
    public void sqlInjectionServiceMethods() {
    }

    /**
     * 在方法执行前执行不安全的SQL注入操作
     */
    @Before("sqlInjectionServiceMethods()")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在AOP切面中通过字符串拼接构造不安全的SQL查询",
            remediation = "使用参数化查询替代字符串拼接",
            level = VulnerabilityLevel.CRITICAL
    )
    public void beforeUnsafeSqlExecution() {
        // 不安全的SQL查询示例
        String username = "1; delete from users where id = 1";
        String unsafeSql = "SELECT * FROM users WHERE username = '" + username + "'";
        // 记录不安全的SQL注入操作
        System.out.println("执行不安全的SQL查询: " + unsafeSql);

    }

    /**
     * 在方法执行后执行安全的SQL查询操作
     */
    @After("sqlInjectionServiceMethods()")
    public void afterSafeSqlExecution() {
        // 安全的SQL查询示例

        // 使用参数化查询
        String safeSql = "SELECT * FROM users WHERE username = ran";
        List<Map<String, Object>> result = jdbcTemplate.queryForList(safeSql);
        // 记录安全的SQL查询操作
        System.out.println("执行安全的SQL查询：参数化查询");

    }

    /**
     * 针对findUsersByAspectUnsafe方法的特定切面
     */
    @Before("sqlInjectionServiceMethods()")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在Before切面中直接执行不安全的SQL查询",
            remediation = "使用参数化查询替代字符串拼接",
            level = VulnerabilityLevel.CRITICAL
    )
    public List<Map<String, Object>> executeUnsafeSql(String name) {
        // 直接执行不安全的SQL查询
        String username = "1; delete from users where id = 1";
        String unsafeSql = "SELECT * FROM users WHERE username LIKE '%" + username + "%'";
        return jdbcTemplate.queryForList(name);
    }

    /**
     * 针对findUsersByAspectSafe方法的特定切面
     */
    @Before("sqlInjectionServiceMethods()")
    public List<Map<String, Object>> executeSafeSql() {
        // 执行安全的SQL查询
        String username = "1";
        String safeSql = "SELECT * FROM users WHERE username LIKE CONCAT('%', ?, '%')";
        return jdbcTemplate.queryForList(safeSql, username);
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/config/AppConfig.java
2025-03-25 23:14:20,123 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742915662-xchaSle9n3n1OHjn8tnq', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915662, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.config;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.stereotype.Component;\n\n/**\n * 应用配置类\n * 演示如何使用@Value注解从配置文件中获取配置项\n */\n@Configuration\n@Component\npublic class AppConfig {\n\n    // 应用基本配置\n    // 原注解: @Value("${spring.application.name}")\n    private String applicationName = "java-benchmark";\n\n    // 原注解: @Value("${server.port}")\n    private int serverPort = 8080;\n\n    // 数据源配置\n    // 原注解: @Value("${spring.datasource.url}")\n    private String datasourceUrl = "jdbc:h2:mem:testdb";\n\n    // 原注解: @Value("${spring.datasource.username}")\n    private String datasourceUsername = "sa";\n\n    // 原注解: @Value("${spring.datasource.password}")\n    private String datasourcePassword = "password";\n\n    // 自定义属性\n    // 原注解: @Value("${app.upload.directory}")\n    private String uploadDirectory = "/var/uploads";\n\n    // 原注解: @Value("${app.command.executor}")\n    private String commandExecutor = "/bin/bash";\n\n    // 原注解: @Value("${app.database.query.template}")\n    private String queryTemplate = "SELECT * FROM {table} WHERE {condition}";\n\n    // 原注解: @Value("${app.security.enabled}")\n    private boolean securityEnabled = true;\n\n    // 可以设置默认值的配置项\n    // 原注解: @Value("${app.timeout}")\n    private int timeout = 30000;\n\n    // 原注解: @Value("${app.max-connections}")\n    private int maxConnections = 100;\n\n    // 获取系统属性\n    // 原注解: @Value("${user.home}")\n    private String userHome = System.getProperty("user.home");\n\n    /**\n     * 获取应用名称\n     */\n    public String getApplicationName() {\n        return applicationName;\n    }\n\n    /**\n     * 获取服务器端口\n     */\n    public int getServerPort() {\n        return serverPort;\n    }\n\n    /**\n     * 获取数据源URL\n     */\n    public String getDatasourceUrl() {\n        return datasourceUrl;\n    }\n\n    /**\n     * 获取数据源用户名\n     */\n    public String getDatasourceUsername() {\n        return datasourceUsername;\n    }\n\n    /**\n     * 获取数据源密码\n     */\n    public String getDatasourcePassword() {\n        return datasourcePassword;\n    }\n\n    /**\n     * 获取上传目录\n     */\n    public String getUploadDirectory() {\n        return uploadDirectory;\n    }\n\n    /**\n     * 获取命令执行器\n     */\n    public String getCommandExecutor() {\n        return commandExecutor;\n    }\n\n    /**\n     * 获取查询模板\n     */\n    public String getQueryTemplate() {\n        return queryTemplate;\n    }\n\n    /**\n     * 检查安全是否启用\n     */\n    public boolean isSecurityEnabled() {\n        return securityEnabled;\n    }\n\n    /**\n     * 获取超时时间\n     */\n    public int getTimeout() {\n        return timeout;\n    }\n\n    /**\n     * 获取最大连接数\n     */\n    public int getMaxConnections() {\n        return maxConnections;\n    }\n\n    /**\n     * 获取用户主目录\n     */\n    public String getUserHome() {\n        return userHome;\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 10392, 'completion_tokens': 955, 'total_tokens': 11347}}
-----------

package edu.thu.benchmark.annotated.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;

/**
 * 应用配置类
 * 演示如何使用@Value注解从配置文件中获取配置项
 */
@Configuration
@Component
public class AppConfig {

    // 应用基本配置
    // 原注解: @Value("${spring.application.name}")
    private String applicationName = "java-benchmark";

    // 原注解: @Value("${server.port}")
    private int serverPort = 8080;

    // 数据源配置
    // 原注解: @Value("${spring.datasource.url}")
    private String datasourceUrl = "jdbc:h2:mem:testdb";

    // 原注解: @Value("${spring.datasource.username}")
    private String datasourceUsername = "sa";

    // 原注解: @Value("${spring.datasource.password}")
    private String datasourcePassword = "password";

    // 自定义属性
    // 原注解: @Value("${app.upload.directory}")
    private String uploadDirectory = "/var/uploads";

    // 原注解: @Value("${app.command.executor}")
    private String commandExecutor = "/bin/bash";

    // 原注解: @Value("${app.database.query.template}")
    private String queryTemplate = "SELECT * FROM {table} WHERE {condition}";

    // 原注解: @Value("${app.security.enabled}")
    private boolean securityEnabled = true;

    // 可以设置默认值的配置项
    // 原注解: @Value("${app.timeout}")
    private int timeout = 30000;

    // 原注解: @Value("${app.max-connections}")
    private int maxConnections = 100;

    // 获取系统属性
    // 原注解: @Value("${user.home}")
    private String userHome = System.getProperty("user.home");

    /**
     * 获取应用名称
     */
    public String getApplicationName() {
        return applicationName;
    }

    /**
     * 获取服务器端口
     */
    public int getServerPort() {
        return serverPort;
    }

    /**
     * 获取数据源URL
     */
    public String getDatasourceUrl() {
        return datasourceUrl;
    }

    /**
     * 获取数据源用户名
     */
    public String getDatasourceUsername() {
        return datasourceUsername;
    }

    /**
     * 获取数据源密码
     */
    public String getDatasourcePassword() {
        return datasourcePassword;
    }

    /**
     * 获取上传目录
     */
    public String getUploadDirectory() {
        return uploadDirectory;
    }

    /**
     * 获取命令执行器
     */
    public String getCommandExecutor() {
        return commandExecutor;
    }

    /**
     * 获取查询模板
     */
    public String getQueryTemplate() {
        return queryTemplate;
    }

    /**
     * 检查安全是否启用
     */
    public boolean isSecurityEnabled() {
        return securityEnabled;
    }

    /**
     * 获取超时时间
     */
    public int getTimeout() {
        return timeout;
    }

    /**
     * 获取最大连接数
     */
    public int getMaxConnections() {
        return maxConnections;
    }

    /**
     * 获取用户主目录
     */
    public String getUserHome() {
        return userHome;
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/config/DatabaseConfig.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/config/DatabaseConfig.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/config/WebMvcConfig.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/config/WebMvcConfig.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/CommandController.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/controller/CommandController.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/CommandInjectionController.java
2025-03-25 23:14:35,282 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
2025-03-25 23:15:37,030 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742915677-tbZQJTL1jq1IMghclDkD', 'provider': 'Amazon Bedrock', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915677, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.controller;\n\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport edu.thu.benchmark.annotated.aspect.CommandExecutionAspect;\nimport edu.thu.benchmark.annotated.service.CommandService;\nimport edu.thu.benchmark.annotated.util.CommandUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * 命令注入测试控制器\n * 包含20个测试用例，10个正例（存在漏洞）和10个负例（安全实现）\n */\n@RestController\n@RequestMapping("/command")\npublic class CommandInjectionController {\n\n    // 原注解: @Value("${command.allowed.prefix}")\n    private String allowedCommandPrefix = "ls,cat,echo,pwd,grep,find";\n\n    // 原注解: @Autowired\n    private CommandService commandService = new CommandService();\n\n    // 原注解: @Autowired\n    private CommandExecutionAspect commandExecutionAspect = new CommandExecutionAspect();\n\n    // ======== 测试用例 - 正例（存在命令注入漏洞） ========\n\n    /**\n     * 测试用例1：直接拼接命令 - 不安全实现\n     */\n    @GetMapping("/01")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "直接拼接用户输入到命令字符串中",\n            remediation = "使用ProcessBuilder并单独指定每个参数，避免使用shell解释器",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public String executeCommand01(@RequestParam String command) throws IOException {\n        Process process = Runtime.getRuntime().exec("ls " + command); // 不安全：直接拼接命令\n        return readProcessOutput(process);\n    }\n\n    /**\n     * 测试用例2：使用系统属性构建命令 - 不安全实现\n     */\n    @GetMapping("/02")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "将用户输入与系统属性拼接形成命令",\n            remediation = "使用命令白名单或使用ProcessBuilder避免shell注入",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public String executeWithSystemProperty02(@RequestParam String path) throws IOException {\n        String userDir = System.getProperty("user.dir");\n        Process process = Runtime.getRuntime().exec("cd " + userDir + " && ls " + path); // 不安全：拼接多个命令\n        return readProcessOutput(process);\n    }\n\n    /**\n     * 测试用例3：使用Runtime.exec数组形式但仍有注入点 - 不安全实现\n     */\n    @GetMapping("/03")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "虽然使用数组方式，但命令中包含shell特殊字符",\n            remediation = "避免在命令参数中包含shell解释的特殊字符",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public String executeArrayWithInjection03(@RequestParam String file) throws IOException {\n        // 不安全：file参数可能包含 && 或 ; 等命令连接符\n        String[] command = new String[]{"/bin/sh", "-c", "cat " + file};\n        Process process = Runtime.getRuntime().exec(command);\n        return readProcessOutput(process);\n    }\n\n    /**\n     * 测试用例4：通过依赖注入的Service执行命令 - 不安全实现\n     */\n    @GetMapping("/04")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "通过依赖注入的Service执行未经验证的命令",\n            remediation = "在Service层实现命令验证逻辑",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public String executeViaService04(@RequestParam String command) throws IOException {\n        return commandService.executeCommandUnsafe(command); // 不安全：在Service中未验证命令\n    }\n\n    /**\n     * 测试用例5：通过AOP切面执行命令 - 不安全实现\n     */\n    @GetMapping("/05")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "通过AOP切面执行未经验证的命令",\n            remediation = "在AOP切面中实现命令验证逻辑",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public String executeViaAspect05(@RequestParam String command) {\n        // 不安全：通过切面执行的命令但切面中未验证命令\n        return commandExecutionAspect.executeCommandUnsafe(command);\n    }\n\n    /**\n     * 测试用例6：使用ProcessBuilder但仍拼接命令 - 不安全实现\n     */\n    @GetMapping("/06")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "使用ProcessBuilder但仍将用户输入拼接到命令中",\n            remediation = "使用ProcessBuilder的command方法分别添加每个参数",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public String executeWithProcessBuilder06(@RequestParam String arg) throws IOException {\n        ProcessBuilder processBuilder = new ProcessBuilder("ls", "-la " + arg); // 不安全：参数中包含拼接\n        Process process = processBuilder.start();\n        return readProcessOutput(process);\n    }\n\n    /**\n     * 测试用例7：从配置文件读取命令前缀 - 不安全实现\n     */\n    @GetMapping("/07")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "从配置中读取命令前缀后仍将用户输入直接拼接",\n            remediation = "使用白名单验证完整命令，不仅仅是前缀",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public String executeWithConfigPrefix07(@RequestParam String command) throws IOException {\n        // 不安全：仅验证前缀但不限制后续参数\n        String[] allowedPrefixes = allowedCommandPrefix.split(",");\n        String[] parts = command.split("\\\\s+", 2);\n\n        if (parts.length > 0 && Arrays.asList(allowedPrefixes).contains(parts[0])) {\n            Process process = Runtime.getRuntime().exec(command); // 不安全：用户仍可添加 && 或 ; 等连接其他命令\n            return readProcessOutput(process);\n        }\n\n        return "Command not allowed";\n    }\n\n    /**\n     * 测试用例8：使用工具类执行命令 - 不安全实现\n     */\n    @GetMapping("/08")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "通过工具类执行未经验证的命令",\n            remediation = "在工具类中实现命令验证逻辑",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public String executeViaUtils08(@RequestParam String command) {\n        return CommandUtils.executeUnsafe(command); // 不安全：在工具类中未验证命令\n    }\n\n    /**\n     * 测试用例9：传入多个参数构建命令 - 不安全实现\n     */\n    @GetMapping("/09")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "使用多个用户参数构建命令字符串",\n            remediation = "使用ProcessBuilder并对每个参数单独验证",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public String executeWithMultipleParams09(@RequestParam String dir, @RequestParam String filter) throws IOException {\n        // 不安全：多个参数拼接，用户可在任一参数中包含命令连接符\n        String command = "cd " + dir + " && ls " + filter;\n        Process process = Runtime.getRuntime().exec(new String[]{"/bin/sh", "-c", command});\n        return readProcessOutput(process);\n    }\n\n    /**\n     * 测试用例10：使用命令执行文件操作 - 不安全实现\n     */\n    @GetMapping("/10")\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.OS_COMMAND_INJECTION,\n            description = "使用命令执行文件操作而不是使用API",\n            remediation = "使用Java文件API代替命令行执行文件操作",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public String fileOperationWithCommand10(@RequestParam String fileName) throws IOException {\n        // 不安全：使用命令行执行文件操作，fileName可能包含恶意命令\n        Process process = Runtime.getRuntime().exec("cat " + fileName);\n        return readProcessOutput(process);\n    }\n\n    // ======== 测试用例 - 负例（安全实现） ========\n\n    /**\n     * 测试用例11：使用ProcessBuilder安全执行命令\n     */\n    @GetMapping("/11")\n    public String executeCommandSafe01(@RequestParam String fileName) throws IOException {\n        // 安全：使用ProcessBuilder并分别指定每个参数\n        ProcessBuilder processBuilder = new ProcessBuilder("ls", fileName);\n        Process process = processBuilder.start();\n        return readProcessOutput(process);\n    }\n\n    /**\n     * 测试用例12：使用命令白名单\n     */\n    @GetMapping("/12")\n    public String executeWithWhitelistSafe02(@RequestParam String command) throws IOException {\n        // 安全：使用白名单限制可执行的命令\n        List<String> allowedCommands = Arrays.asList("ls -l", "ls -la", "echo hello", "date");\n\n        if (allowedCommands.contains(command)) {\n            Process process = Runtime.getRuntime().exec(command);\n            return readProcessOutput(process);\n        }\n\n        return "Command not allowed";\n    }\n\n    /**\n     * 测试用例13：安全使用Runtime.exec数组形式\n     */\n    @GetMapping("/13")\n    public String executeArraySafe03(@RequestParam String file) throws IOException {\n        // 安全：使用数组形式并分别指定每个参数，不使用shell\n        String[] command = new String[]{"cat", file};\n        Process process = Runtime.getRuntime().exec(command);\n        return readProcessOutput(process);\n    }\n\n    /**\n     * 测试用例14：通过依赖注入的Service安全执行命令\n     */\n    @GetMapping("/14")\n    public String executeViaServiceSafe04(@RequestParam String command) throws IOException {\n        return commandService.executeCommandSafe(command); // 安全：在Service中验证命令\n    }\n\n    /**\n     * 测试用例15：通过AOP切面安全执行命令\n     */\n    @GetMapping("/15")\n    public String executeViaAspectSafe05(@RequestParam String command) {\n        // 安全：使用切面的安全实现执行命令\n        return commandExecutionAspect.executeCommandSafe(command);\n    }\n\n    /**\n     * 测试用例16：使用ProcessBuilder添加参数方式\n     */\n    @GetMapping("/16")\n    public String executeWithProcessBuilderSafe06(@RequestParam String dir, @RequestParam String filter) throws IOException {\n        // 安全：使用ProcessBuilder的command方法添加参数\n        List<String> commands = new ArrayList<>();\n        commands.add("ls");\n\n        // 验证参数不包含特殊字符\n        if (!filter.matches(".*[;&|`\\\\\\\\\\"\'$].*")) {\n            if (filter.length() > 0) {\n                commands.add("-la");\n                commands.add(filter);\n            }\n        }\n\n        ProcessBuilder processBuilder = new ProcessBuilder(commands);\n\n        // 设置工作目录而不是在命令中使用cd\n        if (dir != null && !dir.isEmpty() && !dir.contains("..")) {\n            processBuilder.directory(new java.io.File(dir));\n        }\n\n        Process process = processBuilder.start();\n        return readProcessOutput(process);\n    }\n\n    /**\n     * 测试用例17：从配置文件读取并完全验证命令\n     */\n    @GetMapping("/17")\n    public String executeWithFullValidation07(@RequestParam String command) throws IOException {\n        // 安全：完全验证命令及其参数\n        String[] allowedPrefixes = allowedCommandPrefix.split(",");\n        String[] parts = command.split("\\\\s+", 2);\n\n        if (parts.length > 0 && Arrays.asList(allowedPrefixes).contains(parts[0])) {\n            // 验证参数不包含危险字符\n            if (parts.length == 1 || !parts[1].matches(".*[;&|`\\\\\\\\\\"\'$].*")) {\n                ProcessBuilder processBuilder = new ProcessBuilder();\n                if (parts.length == 1) {\n                    processBuilder.command(parts[0]);\n                } else {\n                    processBuilder.command(parts[0], parts[1]);\n                }\n                Process process = processBuilder.start();\n                return readProcessOutput(process);\n            }\n        }\n\n        return "Command not allowed";\n    }\n\n    /**\n     * 测试用例18：使用工具类安全执行命令\n     */\n    @GetMapping("/18")\n    public String executeViaUtilsSafe08(@RequestParam String command) {\n        return CommandUtils.executeSafe(command); // 安全：在工具类中验证命令\n    }\n\n    /**\n     * 测试用例19：使用Java API替代命令行\n     */\n    @GetMapping("/19")\n    public String executeWithJavaApiSafe09(@RequestParam String dir, @RequestParam String filter) {\n        // 安全：使用Java API实现功能而不使用命令行\n        try {\n            java.nio.file.Path dirPath = java.nio.file.Paths.get(dir).normalize();\n\n            // 验证路径是否在安全目录内\n            if (dirPath.startsWith(java.nio.file.Paths.get("/safe/path").normalize())) {\n                return java.nio.file.Files.list(dirPath)\n                        .filter(path -> path.getFileName().toString().contains(filter))\n                        .map(path -> path.getFileName().toString())\n                        .collect(Collectors.joining("\\n"));\n            }\n            return "Directory not allowed";\n        } catch (IOException e) {\n            return "Error: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 测试用例20：使用安全的文件API替代命令行\n     */\n    @GetMapping("/20")\n    public String fileOperationWithApiSafe10(@RequestParam String fileName) {\n        // 安全：使用Java文件API代替命令行读取文件\n        try {\n            java.nio.file.Path filePath = java.nio.file.Paths.get(fileName).normalize();\n\n            // 验证文件路径是否在安全目录内\n            if (filePath.startsWith(java.nio.file.Paths.get("/safe/path").normalize())) {\n                return new String(java.nio.file.Files.readAllBytes(filePath));\n            }\n            return "File access not allowed";\n        } catch (IOException e) {\n            return "Error: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 辅助方法：读取进程输出\n     */\n    private String readProcessOutput(Process process) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append("\\n");\n            }\n            return output.toString();\n        }\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 16624, 'completion_tokens': 4605, 'total_tokens': 21229}}
-----------

package edu.thu.benchmark.annotated.controller;

import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import edu.thu.benchmark.annotated.aspect.CommandExecutionAspect;
import edu.thu.benchmark.annotated.service.CommandService;
import edu.thu.benchmark.annotated.util.CommandUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 命令注入测试控制器
 * 包含20个测试用例，10个正例（存在漏洞）和10个负例（安全实现）
 */
@RestController
@RequestMapping("/command")
public class CommandInjectionController {

    // 原注解: @Value("${command.allowed.prefix}")
    private String allowedCommandPrefix = "ls,cat,echo,pwd,grep,find";

    // 原注解: @Autowired
    private CommandService commandService = new CommandService();

    // 原注解: @Autowired
    private CommandExecutionAspect commandExecutionAspect = new CommandExecutionAspect();

    // ======== 测试用例 - 正例（存在命令注入漏洞） ========

    /**
     * 测试用例1：直接拼接命令 - 不安全实现
     */
    @GetMapping("/01")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "直接拼接用户输入到命令字符串中",
            remediation = "使用ProcessBuilder并单独指定每个参数，避免使用shell解释器",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public String executeCommand01(@RequestParam String command) throws IOException {
        Process process = Runtime.getRuntime().exec("ls " + command); // 不安全：直接拼接命令
        return readProcessOutput(process);
    }

    /**
     * 测试用例2：使用系统属性构建命令 - 不安全实现
     */
    @GetMapping("/02")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "将用户输入与系统属性拼接形成命令",
            remediation = "使用命令白名单或使用ProcessBuilder避免shell注入",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public String executeWithSystemProperty02(@RequestParam String path) throws IOException {
        String userDir = System.getProperty("user.dir");
        Process process = Runtime.getRuntime().exec("cd " + userDir + " && ls " + path); // 不安全：拼接多个命令
        return readProcessOutput(process);
    }

    /**
     * 测试用例3：使用Runtime.exec数组形式但仍有注入点 - 不安全实现
     */
    @GetMapping("/03")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "虽然使用数组方式，但命令中包含shell特殊字符",
            remediation = "避免在命令参数中包含shell解释的特殊字符",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public String executeArrayWithInjection03(@RequestParam String file) throws IOException {
        // 不安全：file参数可能包含 && 或 ; 等命令连接符
        String[] command = new String[]{"/bin/sh", "-c", "cat " + file};
        Process process = Runtime.getRuntime().exec(command);
        return readProcessOutput(process);
    }

    /**
     * 测试用例4：通过依赖注入的Service执行命令 - 不安全实现
     */
    @GetMapping("/04")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "通过依赖注入的Service执行未经验证的命令",
            remediation = "在Service层实现命令验证逻辑",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public String executeViaService04(@RequestParam String command) throws IOException {
        return commandService.executeCommandUnsafe(command); // 不安全：在Service中未验证命令
    }

    /**
     * 测试用例5：通过AOP切面执行命令 - 不安全实现
     */
    @GetMapping("/05")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "通过AOP切面执行未经验证的命令",
            remediation = "在AOP切面中实现命令验证逻辑",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public String executeViaAspect05(@RequestParam String command) {
        // 不安全：通过切面执行的命令但切面中未验证命令
        return commandExecutionAspect.executeCommandUnsafe(command);
    }

    /**
     * 测试用例6：使用ProcessBuilder但仍拼接命令 - 不安全实现
     */
    @GetMapping("/06")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "使用ProcessBuilder但仍将用户输入拼接到命令中",
            remediation = "使用ProcessBuilder的command方法分别添加每个参数",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public String executeWithProcessBuilder06(@RequestParam String arg) throws IOException {
        ProcessBuilder processBuilder = new ProcessBuilder("ls", "-la " + arg); // 不安全：参数中包含拼接
        Process process = processBuilder.start();
        return readProcessOutput(process);
    }

    /**
     * 测试用例7：从配置文件读取命令前缀 - 不安全实现
     */
    @GetMapping("/07")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "从配置中读取命令前缀后仍将用户输入直接拼接",
            remediation = "使用白名单验证完整命令，不仅仅是前缀",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public String executeWithConfigPrefix07(@RequestParam String command) throws IOException {
        // 不安全：仅验证前缀但不限制后续参数
        String[] allowedPrefixes = allowedCommandPrefix.split(",");
        String[] parts = command.split("\\s+", 2);

        if (parts.length > 0 && Arrays.asList(allowedPrefixes).contains(parts[0])) {
            Process process = Runtime.getRuntime().exec(command); // 不安全：用户仍可添加 && 或 ; 等连接其他命令
            return readProcessOutput(process);
        }

        return "Command not allowed";
    }

    /**
     * 测试用例8：使用工具类执行命令 - 不安全实现
     */
    @GetMapping("/08")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "通过工具类执行未经验证的命令",
            remediation = "在工具类中实现命令验证逻辑",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public String executeViaUtils08(@RequestParam String command) {
        return CommandUtils.executeUnsafe(command); // 不安全：在工具类中未验证命令
    }

    /**
     * 测试用例9：传入多个参数构建命令 - 不安全实现
     */
    @GetMapping("/09")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "使用多个用户参数构建命令字符串",
            remediation = "使用ProcessBuilder并对每个参数单独验证",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public String executeWithMultipleParams09(@RequestParam String dir, @RequestParam String filter) throws IOException {
        // 不安全：多个参数拼接，用户可在任一参数中包含命令连接符
        String command = "cd " + dir + " && ls " + filter;
        Process process = Runtime.getRuntime().exec(new String[]{"/bin/sh", "-c", command});
        return readProcessOutput(process);
    }

    /**
     * 测试用例10：使用命令执行文件操作 - 不安全实现
     */
    @GetMapping("/10")
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.OS_COMMAND_INJECTION,
            description = "使用命令执行文件操作而不是使用API",
            remediation = "使用Java文件API代替命令行执行文件操作",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public String fileOperationWithCommand10(@RequestParam String fileName) throws IOException {
        // 不安全：使用命令行执行文件操作，fileName可能包含恶意命令
        Process process = Runtime.getRuntime().exec("cat " + fileName);
        return readProcessOutput(process);
    }

    // ======== 测试用例 - 负例（安全实现） ========

    /**
     * 测试用例11：使用ProcessBuilder安全执行命令
     */
    @GetMapping("/11")
    public String executeCommandSafe01(@RequestParam String fileName) throws IOException {
        // 安全：使用ProcessBuilder并分别指定每个参数
        ProcessBuilder processBuilder = new ProcessBuilder("ls", fileName);
        Process process = processBuilder.start();
        return readProcessOutput(process);
    }

    /**
     * 测试用例12：使用命令白名单
     */
    @GetMapping("/12")
    public String executeWithWhitelistSafe02(@RequestParam String command) throws IOException {
        // 安全：使用白名单限制可执行的命令
        List<String> allowedCommands = Arrays.asList("ls -l", "ls -la", "echo hello", "date");

        if (allowedCommands.contains(command)) {
            Process process = Runtime.getRuntime().exec(command);
            return readProcessOutput(process);
        }

        return "Command not allowed";
    }

    /**
     * 测试用例13：安全使用Runtime.exec数组形式
     */
    @GetMapping("/13")
    public String executeArraySafe03(@RequestParam String file) throws IOException {
        // 安全：使用数组形式并分别指定每个参数，不使用shell
        String[] command = new String[]{"cat", file};
        Process process = Runtime.getRuntime().exec(command);
        return readProcessOutput(process);
    }

    /**
     * 测试用例14：通过依赖注入的Service安全执行命令
     */
    @GetMapping("/14")
    public String executeViaServiceSafe04(@RequestParam String command) throws IOException {
        return commandService.executeCommandSafe(command); // 安全：在Service中验证命令
    }

    /**
     * 测试用例15：通过AOP切面安全执行命令
     */
    @GetMapping("/15")
    public String executeViaAspectSafe05(@RequestParam String command) {
        // 安全：使用切面的安全实现执行命令
        return commandExecutionAspect.executeCommandSafe(command);
    }

    /**
     * 测试用例16：使用ProcessBuilder添加参数方式
     */
    @GetMapping("/16")
    public String executeWithProcessBuilderSafe06(@RequestParam String dir, @RequestParam String filter) throws IOException {
        // 安全：使用ProcessBuilder的command方法添加参数
        List<String> commands = new ArrayList<>();
        commands.add("ls");

        // 验证参数不包含特殊字符
        if (!filter.matches(".*[;&|`\\\\\"'$].*")) {
            if (filter.length() > 0) {
                commands.add("-la");
                commands.add(filter);
            }
        }

        ProcessBuilder processBuilder = new ProcessBuilder(commands);

        // 设置工作目录而不是在命令中使用cd
        if (dir != null && !dir.isEmpty() && !dir.contains("..")) {
            processBuilder.directory(new java.io.File(dir));
        }

        Process process = processBuilder.start();
        return readProcessOutput(process);
    }

    /**
     * 测试用例17：从配置文件读取并完全验证命令
     */
    @GetMapping("/17")
    public String executeWithFullValidation07(@RequestParam String command) throws IOException {
        // 安全：完全验证命令及其参数
        String[] allowedPrefixes = allowedCommandPrefix.split(",");
        String[] parts = command.split("\\s+", 2);

        if (parts.length > 0 && Arrays.asList(allowedPrefixes).contains(parts[0])) {
            // 验证参数不包含危险字符
            if (parts.length == 1 || !parts[1].matches(".*[;&|`\\\\\"'$].*")) {
                ProcessBuilder processBuilder = new ProcessBuilder();
                if (parts.length == 1) {
                    processBuilder.command(parts[0]);
                } else {
                    processBuilder.command(parts[0], parts[1]);
                }
                Process process = processBuilder.start();
                return readProcessOutput(process);
            }
        }

        return "Command not allowed";
    }

    /**
     * 测试用例18：使用工具类安全执行命令
     */
    @GetMapping("/18")
    public String executeViaUtilsSafe08(@RequestParam String command) {
        return CommandUtils.executeSafe(command); // 安全：在工具类中验证命令
    }

    /**
     * 测试用例19：使用Java API替代命令行
     */
    @GetMapping("/19")
    public String executeWithJavaApiSafe09(@RequestParam String dir, @RequestParam String filter) {
        // 安全：使用Java API实现功能而不使用命令行
        try {
            java.nio.file.Path dirPath = java.nio.file.Paths.get(dir).normalize();

            // 验证路径是否在安全目录内
            if (dirPath.startsWith(java.nio.file.Paths.get("/safe/path").normalize())) {
                return java.nio.file.Files.list(dirPath)
                        .filter(path -> path.getFileName().toString().contains(filter))
                        .map(path -> path.getFileName().toString())
                        .collect(Collectors.joining("\n"));
            }
            return "Directory not allowed";
        } catch (IOException e) {
            return "Error: " + e.getMessage();
        }
    }

    /**
     * 测试用例20：使用安全的文件API替代命令行
     */
    @GetMapping("/20")
    public String fileOperationWithApiSafe10(@RequestParam String fileName) {
        // 安全：使用Java文件API代替命令行读取文件
        try {
            java.nio.file.Path filePath = java.nio.file.Paths.get(fileName).normalize();

            // 验证文件路径是否在安全目录内
            if (filePath.startsWith(java.nio.file.Paths.get("/safe/path").normalize())) {
                return new String(java.nio.file.Files.readAllBytes(filePath));
            }
            return "File access not allowed";
        } catch (IOException e) {
            return "Error: " + e.getMessage();
        }
    }

    /**
     * 辅助方法：读取进程输出
     */
    private String readProcessOutput(Process process) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            StringBuilder output = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
            return output.toString();
        }
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/FileController.java
{'id': 'gen-1742915740-eNPGy8HUXJo45rbiijP1', 'provider': 'Amazon Bedrock', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915740, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.controller;\n\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.entity.FileInfo;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.service.FileService;\nimport edu.thu.benchmark.annotated.service.impl.FileServiceImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Controller\n@RequestMapping("/files")\npublic class FileController {\n\n    // 原注解: @Autowired\n    private FileService fileService = new FileServiceImpl("./uploads");\n\n    @GetMapping\n    public String filePage(Model model) {\n        model.addAttribute("files", fileService.getAllFiles());\n        return "files";\n    }\n\n    @PostMapping("/upload")\n    @ResponseBody\n    public Map<String, Object> uploadFile(@RequestParam("file") MultipartFile file) {\n        Map<String, Object> response = new HashMap<>();\n\n        try {\n            FileInfo fileInfo = fileService.store(file);\n\n            response.put("success", true);\n            response.put("fileId", fileInfo.getId());\n            response.put("message", "文件上传成功");\n\n        } catch (IOException e) {\n            response.put("success", false);\n            response.put("message", "文件上传失败: " + e.getMessage());\n        }\n\n        return response;\n    }\n\n    @GetMapping("/list")\n    @ResponseBody\n    public List<FileInfo> listFiles() {\n        return fileService.getAllFiles();\n    }\n\n    @Vulnerability(\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            cwe = 22,\n            description = "此方法存在路径遍历漏洞，允许攻击者通过操纵filename参数来访问服务器上任意路径的文件",\n            remediation = "使用Path.normalize()并确保文件路径在预期目录内，验证用户输入并防止相对路径突破",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    @GetMapping("/view/{filename:.+}")\n    @ResponseBody\n    public ResponseEntity<Resource> viewFile(@PathVariable String filename) {\n        // 不安全的实现 - 直接使用用户提供的文件名，容易受到路径遍历攻击\n        Resource resource = fileService.loadByFilename(filename);\n\n        if (resource != null && resource.exists()) {\n            try {\n                String contentType = "application/octet-stream";\n                return ResponseEntity.ok()\n                        .contentType(MediaType.parseMediaType(contentType))\n                        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\\"" + resource.getFilename() + "\\"")\n                        .body(resource);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().build();\n            }\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @Vulnerability(\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            cwe = 22,\n            description = "此方法存在路径遍历漏洞，允许攻击者通过操纵filepath参数来读取服务器上任意路径的文件",\n            remediation = "不应接受用户提供的完整文件路径，而应使用文件ID或其他方式确定安全的文件访问",\n            level = VulnerabilityLevel.CRITICAL,\n            isRealVulnerability = true\n    )\n    @GetMapping("/read")\n    @ResponseBody\n    public ResponseEntity<String> readFile(@RequestParam String filepath) {\n        try {\n            // 极其不安全的实现 - 严重的路径遍历漏洞\n            // 直接接受用户提供的文件路径\n            Resource resource = fileService.loadByPath(filepath);\n\n            if (resource != null && resource.exists()) {\n                String content = new String(Files.readAllBytes(Paths.get(filepath)));\n                return ResponseEntity.ok(content);\n            } else {\n                return ResponseEntity.notFound().build();\n            }\n        } catch (IOException e) {\n            return ResponseEntity.badRequest().body("无法读取文件: " + e.getMessage());\n        }\n    }\n\n    @GetMapping("/download/{id}")\n    @ResponseBody\n    public ResponseEntity<Resource> downloadFile(@PathVariable Integer id) {\n        // 安全实现 - 通过ID查找文件，避免路径遍历\n        Resource resource = fileService.loadById(id);\n\n        if (resource != null && resource.exists()) {\n            try {\n                String contentType = "application/octet-stream";\n                return ResponseEntity.ok()\n                        .contentType(MediaType.parseMediaType(contentType))\n                        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\\"" + resource.getFilename() + "\\"")\n                        .body(resource);\n            } catch (Exception e) {\n                return ResponseEntity.badRequest().build();\n            }\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @PostMapping("/delete/{id}")\n    @ResponseBody\n    public Map<String, Object> deleteFile(@PathVariable Integer id) {\n        Map<String, Object> response = new HashMap<>();\n\n        boolean success = fileService.deleteFile(id);\n\n        response.put("success", success);\n        response.put("message", success ? "文件删除成功" : "文件删除失败");\n\n        return response;\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 9669, 'completion_tokens': 1604, 'total_tokens': 11273}}
-----------

package edu.thu.benchmark.annotated.controller;

import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.entity.FileInfo;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.service.FileService;
import edu.thu.benchmark.annotated.service.impl.FileServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
@RequestMapping("/files")
public class FileController {

    // 原注解: @Autowired
    private FileService fileService = new FileServiceImpl("./uploads");

    @GetMapping
    public String filePage(Model model) {
        model.addAttribute("files", fileService.getAllFiles());
        return "files";
    }

    @PostMapping("/upload")
    @ResponseBody
    public Map<String, Object> uploadFile(@RequestParam("file") MultipartFile file) {
        Map<String, Object> response = new HashMap<>();

        try {
            FileInfo fileInfo = fileService.store(file);

            response.put("success", true);
            response.put("fileId", fileInfo.getId());
            response.put("message", "文件上传成功");

        } catch (IOException e) {
            response.put("success", false);
            response.put("message", "文件上传失败: " + e.getMessage());
        }

        return response;
    }

    @GetMapping("/list")
    @ResponseBody
    public List<FileInfo> listFiles() {
        return fileService.getAllFiles();
    }

    @Vulnerability(
            type = VulnerabilityType.PATH_TRAVERSAL,
            cwe = 22,
            description = "此方法存在路径遍历漏洞，允许攻击者通过操纵filename参数来访问服务器上任意路径的文件",
            remediation = "使用Path.normalize()并确保文件路径在预期目录内，验证用户输入并防止相对路径突破",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    @GetMapping("/view/{filename:.+}")
    @ResponseBody
    public ResponseEntity<Resource> viewFile(@PathVariable String filename) {
        // 不安全的实现 - 直接使用用户提供的文件名，容易受到路径遍历攻击
        Resource resource = fileService.loadByFilename(filename);

        if (resource != null && resource.exists()) {
            try {
                String contentType = "application/octet-stream";
                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(contentType))
                        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
                        .body(resource);
            } catch (Exception e) {
                return ResponseEntity.badRequest().build();
            }
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    @Vulnerability(
            type = VulnerabilityType.PATH_TRAVERSAL,
            cwe = 22,
            description = "此方法存在路径遍历漏洞，允许攻击者通过操纵filepath参数来读取服务器上任意路径的文件",
            remediation = "不应接受用户提供的完整文件路径，而应使用文件ID或其他方式确定安全的文件访问",
            level = VulnerabilityLevel.CRITICAL,
            isRealVulnerability = true
    )
    @GetMapping("/read")
    @ResponseBody
    public ResponseEntity<String> readFile(@RequestParam String filepath) {
        try {
            // 极其不安全的实现 - 严重的路径遍历漏洞
            // 直接接受用户提供的文件路径
            Resource resource = fileService.loadByPath(filepath);

            if (resource != null && resource.exists()) {
                String content = new String(Files.readAllBytes(Paths.get(filepath)));
                return ResponseEntity.ok(content);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (IOException e) {
            return ResponseEntity.badRequest().body("无法读取文件: " + e.getMessage());
        }
    }

    @GetMapping("/download/{id}")
    @ResponseBody
    public ResponseEntity<Resource> downloadFile(@PathVariable Integer id) {
        // 安全实现 - 通过ID查找文件，避免路径遍历
        Resource resource = fileService.loadById(id);

        if (resource != null && resource.exists()) {
            try {
                String contentType = "application/octet-stream";
                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(contentType))
                        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
                        .body(resource);
            } catch (Exception e) {
                return ResponseEntity.badRequest().build();
            }
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    @PostMapping("/delete/{id}")
    @ResponseBody
    public Map<String, Object> deleteFile(@PathVariable Integer id) {
        Map<String, Object> response = new HashMap<>();

        boolean success = fileService.deleteFile(id);

        response.put("success", success);
        response.put("message", success ? "文件删除成功" : "文件删除失败");

        return response;
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/HomeController.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/controller/HomeController.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/HttpController.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/controller/HttpController.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/PathTraversalController.java
2025-03-25 23:16:04,624 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
2025-03-25 23:17:09,951 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742915766-ST3v7lynvw8TreDtlxN7', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915766, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.controller;\n\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport edu.thu.benchmark.annotated.aspect.FileAccessAspect;\nimport edu.thu.benchmark.annotated.service.PathTraversalService;\nimport edu.thu.benchmark.annotated.service.TemplateService;\nimport edu.thu.benchmark.annotated.service.ZipService;\nimport edu.thu.benchmark.annotated.util.FileUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.*;\nimport java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.UUID;\n\n/**\n * 路径遍历测试控制器\n * 包含40个测试用例，20个正例（存在漏洞）和20个负例（安全实现）\n */\n@RestController\n@RequestMapping("/path")\npublic class PathTraversalController {\n\n    // 原注解: @Value("${file.base.dir}")\n    private String baseDir = "/tmp/files";\n\n    // 原注解: @Autowired\n    private PathTraversalService pathTraversalService = new PathTraversalService();\n\n    // 原注解: @Autowired\n    private TemplateService templateService = new TemplateService();\n\n    // 原注解: @Autowired\n    private FileAccessAspect fileAccessAspect = new FileAccessAspect();\n\n    // ======== 测试用例 - 正例（存在路径遍历漏洞） ========\n\n    /**\n     * 测试用例1：直接拼接文件路径 - 不安全实现\n     */\n    @GetMapping("/01")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "直接拼接用户输入的文件名到基本路径中没有进行验证",\n            remediation = "使用规范化路径并验证最终路径是否在允许的目录内",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public ResponseEntity<Resource> getFile01(@RequestParam String filename) {\n        File file = new File(baseDir + "/" + filename); // 不安全：直接拼接路径\n        return ResponseEntity.ok()\n                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\\"" + file.getName() + "\\"")\n                .body(new FileSystemResource(file));\n    }\n\n    /**\n     * 测试用例2：访问图片文件 - 不安全实现\n     */\n    @GetMapping("/02")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "从请求参数中获取图片名称后直接拼接到路径中",\n            remediation = "对文件名进行验证，确保不包含../等路径遍历字符",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public ResponseEntity<Resource> getImage02(@RequestParam String imageName) {\n        String imagePath = baseDir + "/images/" + imageName; // 不安全：直接拼接图片路径\n        File imageFile = new File(imagePath);\n        return ResponseEntity.ok()\n                .contentType(MediaType.IMAGE_JPEG)\n                .body(new FileSystemResource(imageFile));\n    }\n\n    /**\n     * 测试用例3：文件下载 - 不安全实现\n     */\n    @GetMapping("/03")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "通过File构造函数直接使用用户输入的路径",\n            remediation = "使用Path.normalize()和Path.startsWith()验证路径合法性",\n            level = VulnerabilityLevel.CRITICAL,\n            isRealVulnerability = true\n    )\n    public ResponseEntity<Resource> downloadFile03(@RequestParam String filePath) {\n        File file = new File(baseDir, filePath); // 不安全：直接使用用户输入构造File对象\n        return ResponseEntity.ok()\n                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\\"" + file.getName() + "\\"")\n                .body(new FileSystemResource(file));\n    }\n\n    /**\n     * 测试用例4：读取文件内容 - 不安全实现\n     */\n    @GetMapping("/04")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "使用FileInputStream直接读取用户指定的文件而不验证路径",\n            remediation = "对文件路径进行白名单验证或使用Path API验证路径",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public String readFileContent04(@RequestParam String filePath) throws IOException {\n        StringBuilder content = new StringBuilder();\n        try (FileInputStream fis = new FileInputStream(baseDir + "/" + filePath); // 不安全：直接拼接路径\n             BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content.append(line).append("\\n");\n            }\n        }\n        return content.toString();\n    }\n\n    /**\n     * 测试用例5：通过依赖注入的Service读取文件 - 不安全实现\n     */\n    @GetMapping("/05")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "通过依赖注入的Service直接读取用户提供的文件路径",\n            remediation = "在Service层实现路径验证逻辑",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public String getFileWithInjection05(@RequestParam String filePath) {\n        return pathTraversalService.readFileUnsafe(filePath); // 不安全：在Service中未验证路径\n    }\n\n    /**\n     * 测试用例6：读取XML文件 - 不安全实现\n     */\n    @GetMapping("/06")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "直接使用XML文件路径而不进行验证",\n            remediation = "对XML文件路径进行验证，确保在安全目录中",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public String getXmlFile06(@RequestParam String xmlFile) throws IOException {\n        File file = new File(baseDir + "/config/" + xmlFile); // 不安全：直接拼接XML文件路径\n        return new String(Files.readAllBytes(file.toPath()));\n    }\n\n    /**\n     * 测试用例7：通过AOP切面获取日志文件 - 不安全实现\n     */\n    @GetMapping("/07")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "通过AOP切面获取日志文件但不验证路径",\n            remediation = "在AOP切面中实现路径验证逻辑",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public String getLogFile07(@RequestParam String logFile) {\n        // 不安全：通过切面执行的文件访问但切面中未验证路径\n        return fileAccessAspect.accessLogFile(baseDir + "/logs/" + logFile);\n    }\n\n    /**\n     * 测试用例8：读取配置文件 - 不安全实现\n     */\n    @GetMapping("/08")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "使用配置文件路径但允许使用../等字符",\n            remediation = "过滤或规范化输入中的../等路径遍历字符",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public Map<String, String> getConfigFile08(@RequestParam String configFile) throws IOException {\n        Properties props = new Properties();\n        try (FileInputStream fis = new FileInputStream(baseDir + "/config/" + configFile)) { // 不安全：未过滤../等字符\n            props.load(fis);\n        }\n        return (Map) props;\n    }\n\n    /**\n     * 测试用例9：读取属性文件 - 不安全实现\n     */\n    @GetMapping("/09")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "读取属性文件时使用拼接的相对路径",\n            remediation = "使用ClassPathResource或验证路径是否在预期目录",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public Map<String, String> readProperties09(@RequestParam String propFile) throws IOException {\n        Properties props = new Properties();\n        File file = new File("./config/" + propFile); // 不安全：使用相对路径\n        try (FileInputStream fis = new FileInputStream(file)) {\n            props.load(fis);\n        }\n        return (Map) props;\n    }\n\n    /**\n     * 测试用例10：获取模板文件 - 不安全实现\n     */\n    @GetMapping("/10")\n    @Vulnerability(\n            cwe = 22,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "获取模板文件时未验证路径",\n            remediation = "对模板文件路径进行白名单验证",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public String getTemplateFile10(@RequestParam String template) {\n        return templateService.getTemplateUnsafe(template); // 不安全：在Service中未验证模板路径\n    }\n\n    // 其他不安全实现的测试用例省略...\n\n    // ======== 测试用例 - 负例（安全实现） ========\n\n    /**\n     * 测试用例21：直接拼接文件路径 - 安全实现\n     */\n    @GetMapping("/21")\n    public ResponseEntity<Resource> getFileSafe01(@RequestParam String filename) throws IOException {\n        // 安全：规范化路径并验证\n        Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();\n        Path filePath = basePath.resolve(filename).normalize();\n\n        // 验证最终路径是否在允许的目录内\n        if (!filePath.startsWith(basePath)) {\n            throw new SecurityException("Access to the file is not allowed");\n        }\n\n        if (!Files.exists(filePath)) {\n            throw new FileNotFoundException("File not found");\n        }\n\n        return ResponseEntity.ok()\n                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\\"" + filePath.getFileName() + "\\"")\n                .body(new FileSystemResource(filePath.toFile()));\n    }\n\n    /**\n     * 测试用例22：访问图片文件 - 安全实现\n     */\n    @GetMapping("/22")\n    public ResponseEntity<Resource> getImageSafe02(@RequestParam String imageName) {\n        // 安全：验证文件名不包含路径遍历字符\n        if (imageName.contains("..") || imageName.contains("/") || imageName.contains("\\\\")) {\n            throw new SecurityException("Invalid image name");\n        }\n\n        // 进一步验证：只允许特定扩展名\n        if (!imageName.toLowerCase().endsWith(".jpg") &&\n            !imageName.toLowerCase().endsWith(".png") &&\n            !imageName.toLowerCase().endsWith(".gif")) {\n            throw new SecurityException("Invalid image type");\n        }\n\n        Path basePath = Paths.get(baseDir, "images").toAbsolutePath().normalize();\n        Path imagePath = basePath.resolve(imageName).normalize();\n\n        return ResponseEntity.ok()\n                .contentType(MediaType.IMAGE_JPEG)\n                .body(new FileSystemResource(imagePath.toFile()));\n    }\n\n    /**\n     * 测试用例23：文件下载 - 安全实现\n     */\n    @GetMapping("/23")\n    public ResponseEntity<Resource> downloadFileSafe03(@RequestParam String filePath) throws IOException {\n        // 安全：规范化路径并验证\n        Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();\n        Path resolvedPath = basePath.resolve(filePath).normalize();\n\n        // 验证最终路径是否在允许的目录内\n        if (!resolvedPath.startsWith(basePath)) {\n            throw new SecurityException("Access to the file is not allowed");\n        }\n\n        if (!Files.exists(resolvedPath)) {\n            throw new FileNotFoundException("File not found");\n        }\n\n        return ResponseEntity.ok()\n                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\\"" + resolvedPath.getFileName() + "\\"")\n                .body(new FileSystemResource(resolvedPath.toFile()));\n    }\n\n    /**\n     * 测试用例24：读取文件内容 - 安全实现\n     */\n    @GetMapping("/24")\n    public String readFileContentSafe04(@RequestParam String filePath) throws IOException {\n        // 安全：规范化路径并验证\n        Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();\n        Path resolvedPath = basePath.resolve(filePath).normalize();\n\n        // 验证最终路径是否在允许的目录内\n        if (!resolvedPath.startsWith(basePath)) {\n            throw new SecurityException("Access to the file is not allowed");\n        }\n\n        if (!Files.isRegularFile(resolvedPath)) {\n            throw new FileNotFoundException("File not found or not a regular file");\n        }\n\n        return new String(Files.readAllBytes(resolvedPath));\n    }\n\n    /**\n     * 测试用例25：通过依赖注入的Service读取文件 - 安全实现\n     */\n    @GetMapping("/25")\n    public String getFileWithInjectionSafe05(@RequestParam String filePath) {\n        return pathTraversalService.readFileSafe(filePath); // 安全：在Service中验证路径\n    }\n\n    /**\n     * 测试用例26：读取XML文件 - 安全实现\n     */\n    @GetMapping("/26")\n    public String getXmlFileSafe06(@RequestParam String xmlFile) throws IOException {\n        // 安全：验证文件名格式和扩展名\n        if (xmlFile.contains("..") || xmlFile.contains("/") || xmlFile.contains("\\\\")) {\n            throw new SecurityException("Invalid XML file name");\n        }\n\n        if (!xmlFile.toLowerCase().endsWith(".xml")) {\n            throw new SecurityException("File must be an XML file");\n        }\n\n        Path basePath = Paths.get(baseDir, "config").toAbsolutePath().normalize();\n        Path xmlPath = basePath.resolve(xmlFile).normalize();\n\n        if (!xmlPath.startsWith(basePath)) {\n            throw new SecurityException("Access to the XML file is not allowed");\n        }\n\n        return new String(Files.readAllBytes(xmlPath));\n    }\n\n    /**\n     * 测试用例27：通过AOP切面获取日志文件 - 安全实现\n     */\n    @GetMapping("/27")\n    public String getLogFileSafe07(@RequestParam String logFile) {\n        // 安全：验证文件名\n        if (logFile.contains("..") || logFile.contains("/") || logFile.contains("\\\\")) {\n            throw new SecurityException("Invalid log file name");\n        }\n\n        if (!logFile.toLowerCase().endsWith(".log")) {\n            throw new SecurityException("File must be a log file");\n        }\n\n        // 使用安全的切面实现\n        return fileAccessAspect.accessLogFileSafe(logFile);\n    }\n\n    /**\n     * 测试用例28：读取配置文件 - 安全实现\n     */\n    @GetMapping("/28")\n    public Map<String, String> getConfigFileSafe08(@RequestParam String configFile) throws IOException {\n        // 安全：验证文件名\n        if (configFile.contains("..") || configFile.contains("/") || configFile.contains("\\\\")) {\n            throw new SecurityException("Invalid config file name");\n        }\n\n        if (!configFile.toLowerCase().endsWith(".properties") && !configFile.toLowerCase().endsWith(".xml")) {\n            throw new SecurityException("Invalid config file type");\n        }\n\n        Path basePath = Paths.get(baseDir, "config").toAbsolutePath().normalize();\n        Path configPath = basePath.resolve(configFile).normalize();\n\n        if (!configPath.startsWith(basePath)) {\n            throw new SecurityException("Access to the config file is not allowed");\n        }\n\n        Properties props = new Properties();\n        try (FileInputStream fis = new FileInputStream(configPath.toFile())) {\n            props.load(fis);\n        }\n        return (Map) props;\n    }\n\n    /**\n     * 测试用例29：读取属性文件 - 安全实现\n     */\n    @GetMapping("/29")\n    public Map<String, String> readPropertiesSafe09(@RequestParam String propFile) throws IOException {\n        // 安全：使用ClassPathResource从类路径加载资源\n        if (!propFile.endsWith(".properties")) {\n            throw new SecurityException("File must be a properties file");\n        }\n\n        ClassPathResource resource = new ClassPathResource("config/" + propFile);\n        Properties props = new Properties();\n        try (InputStream is = resource.getInputStream()) {\n            props.load(is);\n        }\n        return (Map) props;\n    }\n\n    /**\n     * 测试用例30：获取模板文件 - 安全实现\n     */\n    @GetMapping("/30")\n    public String getTemplateFileSafe10(@RequestParam String template) {\n        // 白名单验证模板名称\n        if (!template.matches("[a-zA-Z0-9_-]+\\\\.html")) {\n            throw new SecurityException("Invalid template name");\n        }\n\n        return templateService.getTemplateSafe(template); // 安全：在Service中验证模板路径\n    }\n\n    // 其他安全实现的测试用例省略...\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 17325, 'completion_tokens': 5138, 'total_tokens': 22463}}
-----------

package edu.thu.benchmark.annotated.controller;

import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import edu.thu.benchmark.annotated.aspect.FileAccessAspect;
import edu.thu.benchmark.annotated.service.PathTraversalService;
import edu.thu.benchmark.annotated.service.TemplateService;
import edu.thu.benchmark.annotated.service.ZipService;
import edu.thu.benchmark.annotated.util.FileUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;

/**
 * 路径遍历测试控制器
 * 包含40个测试用例，20个正例（存在漏洞）和20个负例（安全实现）
 */
@RestController
@RequestMapping("/path")
public class PathTraversalController {

    // 原注解: @Value("${file.base.dir}")
    private String baseDir = "/tmp/files";

    // 原注解: @Autowired
    private PathTraversalService pathTraversalService = new PathTraversalService();

    // 原注解: @Autowired
    private TemplateService templateService = new TemplateService();

    // 原注解: @Autowired
    private FileAccessAspect fileAccessAspect = new FileAccessAspect();

    // ======== 测试用例 - 正例（存在路径遍历漏洞） ========

    /**
     * 测试用例1：直接拼接文件路径 - 不安全实现
     */
    @GetMapping("/01")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "直接拼接用户输入的文件名到基本路径中没有进行验证",
            remediation = "使用规范化路径并验证最终路径是否在允许的目录内",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public ResponseEntity<Resource> getFile01(@RequestParam String filename) {
        File file = new File(baseDir + "/" + filename); // 不安全：直接拼接路径
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getName() + "\"")
                .body(new FileSystemResource(file));
    }

    /**
     * 测试用例2：访问图片文件 - 不安全实现
     */
    @GetMapping("/02")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "从请求参数中获取图片名称后直接拼接到路径中",
            remediation = "对文件名进行验证，确保不包含../等路径遍历字符",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public ResponseEntity<Resource> getImage02(@RequestParam String imageName) {
        String imagePath = baseDir + "/images/" + imageName; // 不安全：直接拼接图片路径
        File imageFile = new File(imagePath);
        return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_JPEG)
                .body(new FileSystemResource(imageFile));
    }

    /**
     * 测试用例3：文件下载 - 不安全实现
     */
    @GetMapping("/03")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "通过File构造函数直接使用用户输入的路径",
            remediation = "使用Path.normalize()和Path.startsWith()验证路径合法性",
            level = VulnerabilityLevel.CRITICAL,
            isRealVulnerability = true
    )
    public ResponseEntity<Resource> downloadFile03(@RequestParam String filePath) {
        File file = new File(baseDir, filePath); // 不安全：直接使用用户输入构造File对象
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getName() + "\"")
                .body(new FileSystemResource(file));
    }

    /**
     * 测试用例4：读取文件内容 - 不安全实现
     */
    @GetMapping("/04")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "使用FileInputStream直接读取用户指定的文件而不验证路径",
            remediation = "对文件路径进行白名单验证或使用Path API验证路径",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public String readFileContent04(@RequestParam String filePath) throws IOException {
        StringBuilder content = new StringBuilder();
        try (FileInputStream fis = new FileInputStream(baseDir + "/" + filePath); // 不安全：直接拼接路径
             BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
        }
        return content.toString();
    }

    /**
     * 测试用例5：通过依赖注入的Service读取文件 - 不安全实现
     */
    @GetMapping("/05")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "通过依赖注入的Service直接读取用户提供的文件路径",
            remediation = "在Service层实现路径验证逻辑",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public String getFileWithInjection05(@RequestParam String filePath) {
        return pathTraversalService.readFileUnsafe(filePath); // 不安全：在Service中未验证路径
    }

    /**
     * 测试用例6：读取XML文件 - 不安全实现
     */
    @GetMapping("/06")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "直接使用XML文件路径而不进行验证",
            remediation = "对XML文件路径进行验证，确保在安全目录中",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public String getXmlFile06(@RequestParam String xmlFile) throws IOException {
        File file = new File(baseDir + "/config/" + xmlFile); // 不安全：直接拼接XML文件路径
        return new String(Files.readAllBytes(file.toPath()));
    }

    /**
     * 测试用例7：通过AOP切面获取日志文件 - 不安全实现
     */
    @GetMapping("/07")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "通过AOP切面获取日志文件但不验证路径",
            remediation = "在AOP切面中实现路径验证逻辑",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public String getLogFile07(@RequestParam String logFile) {
        // 不安全：通过切面执行的文件访问但切面中未验证路径
        return fileAccessAspect.accessLogFile(baseDir + "/logs/" + logFile);
    }

    /**
     * 测试用例8：读取配置文件 - 不安全实现
     */
    @GetMapping("/08")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "使用配置文件路径但允许使用../等字符",
            remediation = "过滤或规范化输入中的../等路径遍历字符",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public Map<String, String> getConfigFile08(@RequestParam String configFile) throws IOException {
        Properties props = new Properties();
        try (FileInputStream fis = new FileInputStream(baseDir + "/config/" + configFile)) { // 不安全：未过滤../等字符
            props.load(fis);
        }
        return (Map) props;
    }

    /**
     * 测试用例9：读取属性文件 - 不安全实现
     */
    @GetMapping("/09")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "读取属性文件时使用拼接的相对路径",
            remediation = "使用ClassPathResource或验证路径是否在预期目录",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public Map<String, String> readProperties09(@RequestParam String propFile) throws IOException {
        Properties props = new Properties();
        File file = new File("./config/" + propFile); // 不安全：使用相对路径
        try (FileInputStream fis = new FileInputStream(file)) {
            props.load(fis);
        }
        return (Map) props;
    }

    /**
     * 测试用例10：获取模板文件 - 不安全实现
     */
    @GetMapping("/10")
    @Vulnerability(
            cwe = 22,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "获取模板文件时未验证路径",
            remediation = "对模板文件路径进行白名单验证",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public String getTemplateFile10(@RequestParam String template) {
        return templateService.getTemplateUnsafe(template); // 不安全：在Service中未验证模板路径
    }

    // 其他不安全实现的测试用例省略...

    // ======== 测试用例 - 负例（安全实现） ========

    /**
     * 测试用例21：直接拼接文件路径 - 安全实现
     */
    @GetMapping("/21")
    public ResponseEntity<Resource> getFileSafe01(@RequestParam String filename) throws IOException {
        // 安全：规范化路径并验证
        Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();
        Path filePath = basePath.resolve(filename).normalize();

        // 验证最终路径是否在允许的目录内
        if (!filePath.startsWith(basePath)) {
            throw new SecurityException("Access to the file is not allowed");
        }

        if (!Files.exists(filePath)) {
            throw new FileNotFoundException("File not found");
        }

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filePath.getFileName() + "\"")
                .body(new FileSystemResource(filePath.toFile()));
    }

    /**
     * 测试用例22：访问图片文件 - 安全实现
     */
    @GetMapping("/22")
    public ResponseEntity<Resource> getImageSafe02(@RequestParam String imageName) {
        // 安全：验证文件名不包含路径遍历字符
        if (imageName.contains("..") || imageName.contains("/") || imageName.contains("\\")) {
            throw new SecurityException("Invalid image name");
        }

        // 进一步验证：只允许特定扩展名
        if (!imageName.toLowerCase().endsWith(".jpg") &&
            !imageName.toLowerCase().endsWith(".png") &&
            !imageName.toLowerCase().endsWith(".gif")) {
            throw new SecurityException("Invalid image type");
        }

        Path basePath = Paths.get(baseDir, "images").toAbsolutePath().normalize();
        Path imagePath = basePath.resolve(imageName).normalize();

        return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_JPEG)
                .body(new FileSystemResource(imagePath.toFile()));
    }

    /**
     * 测试用例23：文件下载 - 安全实现
     */
    @GetMapping("/23")
    public ResponseEntity<Resource> downloadFileSafe03(@RequestParam String filePath) throws IOException {
        // 安全：规范化路径并验证
        Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();
        Path resolvedPath = basePath.resolve(filePath).normalize();

        // 验证最终路径是否在允许的目录内
        if (!resolvedPath.startsWith(basePath)) {
            throw new SecurityException("Access to the file is not allowed");
        }

        if (!Files.exists(resolvedPath)) {
            throw new FileNotFoundException("File not found");
        }

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resolvedPath.getFileName() + "\"")
                .body(new FileSystemResource(resolvedPath.toFile()));
    }

    /**
     * 测试用例24：读取文件内容 - 安全实现
     */
    @GetMapping("/24")
    public String readFileContentSafe04(@RequestParam String filePath) throws IOException {
        // 安全：规范化路径并验证
        Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();
        Path resolvedPath = basePath.resolve(filePath).normalize();

        // 验证最终路径是否在允许的目录内
        if (!resolvedPath.startsWith(basePath)) {
            throw new SecurityException("Access to the file is not allowed");
        }

        if (!Files.isRegularFile(resolvedPath)) {
            throw new FileNotFoundException("File not found or not a regular file");
        }

        return new String(Files.readAllBytes(resolvedPath));
    }

    /**
     * 测试用例25：通过依赖注入的Service读取文件 - 安全实现
     */
    @GetMapping("/25")
    public String getFileWithInjectionSafe05(@RequestParam String filePath) {
        return pathTraversalService.readFileSafe(filePath); // 安全：在Service中验证路径
    }

    /**
     * 测试用例26：读取XML文件 - 安全实现
     */
    @GetMapping("/26")
    public String getXmlFileSafe06(@RequestParam String xmlFile) throws IOException {
        // 安全：验证文件名格式和扩展名
        if (xmlFile.contains("..") || xmlFile.contains("/") || xmlFile.contains("\\")) {
            throw new SecurityException("Invalid XML file name");
        }

        if (!xmlFile.toLowerCase().endsWith(".xml")) {
            throw new SecurityException("File must be an XML file");
        }

        Path basePath = Paths.get(baseDir, "config").toAbsolutePath().normalize();
        Path xmlPath = basePath.resolve(xmlFile).normalize();

        if (!xmlPath.startsWith(basePath)) {
            throw new SecurityException("Access to the XML file is not allowed");
        }

        return new String(Files.readAllBytes(xmlPath));
    }

    /**
     * 测试用例27：通过AOP切面获取日志文件 - 安全实现
     */
    @GetMapping("/27")
    public String getLogFileSafe07(@RequestParam String logFile) {
        // 安全：验证文件名
        if (logFile.contains("..") || logFile.contains("/") || logFile.contains("\\")) {
            throw new SecurityException("Invalid log file name");
        }

        if (!logFile.toLowerCase().endsWith(".log")) {
            throw new SecurityException("File must be a log file");
        }

        // 使用安全的切面实现
        return fileAccessAspect.accessLogFileSafe(logFile);
    }

    /**
     * 测试用例28：读取配置文件 - 安全实现
     */
    @GetMapping("/28")
    public Map<String, String> getConfigFileSafe08(@RequestParam String configFile) throws IOException {
        // 安全：验证文件名
        if (configFile.contains("..") || configFile.contains("/") || configFile.contains("\\")) {
            throw new SecurityException("Invalid config file name");
        }

        if (!configFile.toLowerCase().endsWith(".properties") && !configFile.toLowerCase().endsWith(".xml")) {
            throw new SecurityException("Invalid config file type");
        }

        Path basePath = Paths.get(baseDir, "config").toAbsolutePath().normalize();
        Path configPath = basePath.resolve(configFile).normalize();

        if (!configPath.startsWith(basePath)) {
            throw new SecurityException("Access to the config file is not allowed");
        }

        Properties props = new Properties();
        try (FileInputStream fis = new FileInputStream(configPath.toFile())) {
            props.load(fis);
        }
        return (Map) props;
    }

    /**
     * 测试用例29：读取属性文件 - 安全实现
     */
    @GetMapping("/29")
    public Map<String, String> readPropertiesSafe09(@RequestParam String propFile) throws IOException {
        // 安全：使用ClassPathResource从类路径加载资源
        if (!propFile.endsWith(".properties")) {
            throw new SecurityException("File must be a properties file");
        }

        ClassPathResource resource = new ClassPathResource("config/" + propFile);
        Properties props = new Properties();
        try (InputStream is = resource.getInputStream()) {
            props.load(is);
        }
        return (Map) props;
    }

    /**
     * 测试用例30：获取模板文件 - 安全实现
     */
    @GetMapping("/30")
    public String getTemplateFileSafe10(@RequestParam String template) {
        // 白名单验证模板名称
        if (!template.matches("[a-zA-Z0-9_-]+\\.html")) {
            throw new SecurityException("Invalid template name");
        }

        return templateService.getTemplateSafe(template); // 安全：在Service中验证模板路径
    }

    // 其他安全实现的测试用例省略...
}

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/SqlInjectionTestController.java
{'id': 'gen-1742915831-M4D0F5VX0ypRqIjO2C6f', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915831, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.controller;\n\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport edu.thu.benchmark.annotated.entity.User;\nimport edu.thu.benchmark.annotated.service.SqlInjectionTestService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * SQL注入测试控制器\n * 包含40个测试用例，20个正例（存在漏洞）和20个负例（安全实现）\n */\n@RestController\n@RequestMapping("/sqli")\npublic class SqlInjectionTestController {\n\n    // 原注解: @Autowired\n    private SqlInjectionTestService sqlInjectionTestService = new SqlInjectionTestService();\n    // TODO 如果不还原语义,那么sql注入将无法检测,因为sqlInjectionTestService被认为是null\n\n    // 原注解: @Autowired\n    private JdbcTemplate jdbcTemplate = new JdbcTemplate();\n    // ======== 测试用例 - 正例（存在SQL注入漏洞） ========\n\n    /**\n     * 测试用例1：使用MyBatis XML - LIKE查询 - 不安全实现\n     */\n    @GetMapping("/01")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "使用MyBatis XML中的${username}进行字符串拼接，导致SQL注入漏洞",\n            remediation = "使用#{username}参数绑定代替${username}字符串拼接",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<Map<String,Object>> testCase01(@RequestParam String username) {\n        return sqlInjectionTestService.findUsersByJdbcUnsafe(username);\n    }\n\n\n\n    /**\n     * 测试用例2：使用MyBatis XML - ORDER BY子句 - 不安全实现\n     */\n    @GetMapping("/02")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在ORDER BY子句中使用${sortField}进行字符串拼接，允许注入额外的SQL语句",\n            remediation = "使用白名单验证排序字段或使用预编译语句",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public List<User> testCase02(@RequestParam String sortField) {\n        return sqlInjectionTestService.findUsersSortedUnsafe(sortField);\n    }\n\n    /**\n     * 测试用例3：使用MyBatis XML - IN子句 - 不安全实现\n     */\n    @GetMapping("/03")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在IN子句中使用${idList}进行字符串拼接，允许任意SQL注入",\n            remediation = "使用<foreach>元素或预处理语句构建IN子句",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<User> testCase03(@RequestParam String idList) {\n        return sqlInjectionTestService.findUsersInListUnsafe(idList);\n    }\n\n    /**\n     * 测试用例4：使用MyBatis XML - WHERE子句 - 不安全实现\n     */\n    @GetMapping("/04")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在WHERE子句中使用${whereClause}进行字符串拼接，允许任意SQL注入",\n            remediation = "使用<where>和<if>元素构建动态查询条件",\n            level = VulnerabilityLevel.CRITICAL,\n            isRealVulnerability = true\n    )\n    public List<User> testCase04(@RequestParam String whereClause) {\n        return sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(whereClause);\n    }\n\n    /**\n     * 测试用例5：使用MyBatis XML - LIMIT/OFFSET - 不安全实现\n     */\n    @GetMapping("/05")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在LIMIT和OFFSET子句中使用${limit}和${offset}进行字符串拼接，允许SQL注入",\n            remediation = "使用#{limit}和#{offset}参数绑定，并验证输入是否为数字",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public List<User> testCase05(@RequestParam String limit, @RequestParam String offset) {\n        return sqlInjectionTestService.findUsersWithLimitUnsafe(limit, offset);\n    }\n\n    /**\n     * 测试用例6：使用MyBatis XML - SET子句 - 不安全实现\n     */\n    @PostMapping("/06")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在UPDATE语句的SET子句中使用${setClause}进行字符串拼接，允许任意SQL注入",\n            remediation = "使用<set>和<if>元素构建动态更新语句",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public int testCase06(@RequestParam int id, @RequestParam String setClause) {\n        return sqlInjectionTestService.updateUserDynamicUnsafe(id, setClause);\n    }\n\n    /**\n     * 测试用例7：使用MyBatis XML - DELETE条件 - 不安全实现\n     */\n    @DeleteMapping("/07")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在DELETE语句的WHERE子句中使用${condition}进行字符串拼接，允许任意SQL注入",\n            remediation = "使用参数绑定和预编译语句执行删除操作",\n            level = VulnerabilityLevel.CRITICAL,\n            isRealVulnerability = true\n    )\n    public int testCase07(@RequestParam String condition) {\n        return sqlInjectionTestService.deleteUsersUnsafe(condition);\n    }\n\n    /**\n     * 测试用例8：使用MyBatis注解 - 不安全实现\n     */\n    @GetMapping("/08")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在@Select注解中使用${email}进行字符串拼接，允许SQL注入",\n            remediation = "使用#{email}参数绑定代替${email}字符串拼接",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public User testCase08(@RequestParam String email) {\n        return sqlInjectionTestService.findUserByEmailUnsafe(email);\n    }\n\n    /**\n     * 测试用例9：使用MyBatis注解 - 多参数 - 不安全实现\n     */\n    @GetMapping("/09")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在@Select注解中对多个参数使用${username}和${password}进行字符串拼接，导致SQL注入",\n            remediation = "使用#{username}和#{password}参数绑定代替字符串拼接",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public User testCase09(@RequestParam String username, @RequestParam String password) {\n        return sqlInjectionTestService.findUserByCredentialsUnsafe(username, password);\n    }\n\n    /**\n     * 测试用例10：使用MyBatis注解 - LIKE查询 - 不安全实现\n     */\n    @GetMapping("/10")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在@Select注解的LIKE子句中使用${column}和${value}进行字符串拼接，允许SQL注入",\n            remediation = "使用白名单验证列名，并使用参数绑定处理LIKE模式",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<User> testCase10(@RequestParam String column, @RequestParam String value) {\n        return sqlInjectionTestService.searchUsersUnsafe(column, value);\n    }\n\n    /**\n     * 测试用例11：原生JDBC - 不安全实现\n     */\n    @GetMapping("/11")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "使用JDBC直接拼接查询条件，允许任意SQL注入",\n            remediation = "使用PreparedStatement和参数绑定",\n            level = VulnerabilityLevel.CRITICAL,\n            isRealVulnerability = true\n    )\n    public List<Map<String, Object>> testCase11(@RequestParam String condition) {\n        return sqlInjectionTestService.findUsersByJdbcUnsafe(condition);\n    }\n\n    /**\n     * 测试用例12：配置模板字符串 - 不安全实现\n     */\n    @GetMapping("/12")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "使用来自配置文件的SQL模板和String.format()进行字符串拼接，允许SQL注入",\n            remediation = "使用PreparedStatement和参数绑定代替String.format()",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<Map<String, Object>> testCase12(@RequestParam String username) {\n        return sqlInjectionTestService.findUsersByTemplateUnsafe(username);\n    }\n\n    /**\n     * 测试用例13：NamedParameterJdbcTemplate - 不安全实现\n     */\n    @GetMapping("/13")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "使用NamedParameterJdbcTemplate但仍然拼接WHERE子句，允许SQL注入",\n            remediation = "所有SQL语句都应使用参数化查询，不进行直接拼接",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<Map<String, Object>> testCase13(@RequestParam String whereClause) {\n        Map<String, Object> params = new HashMap<>();\n        params.put("username", "admin");\n        params.put("email", "admin@example.com");\n        return sqlInjectionTestService.findByNamedParamsUnsafe(whereClause, params);\n    }\n\n    /**\n     * 测试用例14：使用AOP切面 - 不安全实现\n     */\n    @GetMapping("/14")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "通过AOP切面执行SQL时使用字符串替换而非参数绑定，允许SQL注入",\n            remediation = "使用PreparedStatement和参数绑定代替字符串替换",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<Map<String, Object>> testCase14(@RequestParam String username) {\n        return sqlInjectionTestService.findUsersByAspectUnsafe(username);\n    }\n\n    /**\n     * 测试用例15：MyBatis XML - LIKE查询 - 半安全实现\n     */\n    @GetMapping("/15")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "在LIKE子句中正确使用参数绑定，但列名仍然使用${column}字符串拼接，允许列名注入",\n            remediation = "使用白名单验证列名，避免拼接列名",\n            level = VulnerabilityLevel.MEDIUM,\n            isRealVulnerability = true\n    )\n    public List<User> testCase15(@RequestParam String column, @RequestParam String value) {\n        return sqlInjectionTestService.searchUsersSemiSafe(column, value);\n    }\n\n    /**\n     * 测试用例16：字符串拼接多个条件 - 不安全实现\n     */\n    @GetMapping("/16")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "手动拼接多个查询条件，允许SQL注入",\n            remediation = "使用参数化查询和动态SQL构建条件",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<User> testCase16(@RequestParam String id, @RequestParam String username) {\n        String whereClause = "id = " + id + " OR username LIKE \'%" + username + "%\'";\n        return sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(whereClause);\n    }\n\n    /**\n     * 测试用例17：字符串模板内联SQL - 不安全实现\n     */\n    @GetMapping("/17")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "使用Java字符串模板进行SQL拼接，允许SQL注入",\n            remediation = "使用参数化查询替代字符串模板",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<Map<String, Object>> testCase17(@RequestParam String id, @RequestParam String username) {\n        String condition = "id = " + id + " OR username = \'" + username + "\'";\n        return sqlInjectionTestService.findUsersByJdbcUnsafe(condition);\n    }\n\n    /**\n     * 测试用例18：自定义SQL拼接 - 不安全实现\n     */\n    @GetMapping("/18")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "手动构建复杂的WHERE子句，允许SQL注入",\n            remediation = "使用参数化查询和ORM框架的动态SQL功能",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<User> testCase18(\n            @RequestParam(required = false) String username,\n            @RequestParam(required = false) String email,\n            @RequestParam(required = false) String sortBy) {\n        StringBuilder whereClause = new StringBuilder();\n        if (username != null) {\n            whereClause.append("username LIKE \'%").append(username).append("%\'");\n        }\n        if (email != null) {\n            if (whereClause.length() > 0) {\n                whereClause.append(" AND ");\n            }\n            whereClause.append("email LIKE \'%").append(email).append("%\'");\n        }\n        if (sortBy != null) {\n            whereClause.append(" ORDER BY ").append(sortBy);\n        }\n        return sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(whereClause.toString());\n    }\n\n    /**\n     * 测试用例19：使用不同的拼接方式 - 不安全实现\n     */\n    @GetMapping("/19")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "使用+运算符拼接SQL语句，允许SQL注入",\n            remediation = "使用参数化查询和参数绑定",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public User testCase19(@RequestParam String id) {\n        String condition = "id = " + id;\n        List<User> users = sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(condition);\n        return users.isEmpty() ? null : users.get(0);\n    }\n\n    /**\n     * 测试用例20：组合多种不安全方式 - 不安全实现\n     */\n    @GetMapping("/20")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "组合多种不安全的SQL拼接方式，允许复杂的SQL注入",\n            remediation = "使用参数化查询和ORM框架的安全特性",\n            level = VulnerabilityLevel.CRITICAL,\n            isRealVulnerability = true\n    )\n    public List<User> testCase20(\n            @RequestParam String field,\n            @RequestParam String value,\n            @RequestParam String orderBy,\n            @RequestParam String limit) {\n        String whereClause = field + " = \'" + value + "\' ORDER BY " + orderBy + " LIMIT " + limit;\n        return sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(whereClause);\n    }\n\n    // ======== 测试用例 - 负例（安全实现） ========\n\n    /**\n     * 测试用例21：使用MyBatis XML - LIKE查询 - 安全实现\n     */\n    @GetMapping("/21")\n    public List<User> testCase21(@RequestParam String username) {\n        return sqlInjectionTestService.findUsersByNameSafe(username);\n    }\n\n    /**\n     * 测试用例22：使用MyBatis XML - ORDER BY子句 - 安全实现\n     */\n    @GetMapping("/22")\n    public List<User> testCase22(@RequestParam String sortField) {\n        return sqlInjectionTestService.findUsersSortedSafe(sortField);\n    }\n\n    /**\n     * 测试用例23：使用MyBatis XML - IN子句 - 安全实现\n     */\n    @GetMapping("/23")\n    public List<User> testCase23(@RequestParam List<Integer> idList) {\n        return sqlInjectionTestService.findUsersInListSafe(idList);\n    }\n\n    /**\n     * 测试用例24：使用MyBatis XML - 多条件查询 - 安全实现\n     */\n    @GetMapping("/24")\n    public List<User> testCase24(\n            @RequestParam(required = false) Integer id,\n            @RequestParam(required = false) String username,\n            @RequestParam(required = false) String email) {\n        return sqlInjectionTestService.findUsersByMultipleConditionsSafe(id, username, email);\n    }\n\n    /**\n     * 测试用例25：使用MyBatis XML - LIMIT/OFFSET - 安全实现\n     */\n    @GetMapping("/25")\n    public List<User> testCase25(@RequestParam int limit, @RequestParam int offset) {\n        return sqlInjectionTestService.findUsersWithLimitSafe(limit, offset);\n    }\n\n    /**\n     * 测试用例26：使用MyBatis XML - SET子句 - 安全实现\n     */\n    @PostMapping("/26")\n    public int testCase26(\n            @RequestParam int id,\n            @RequestParam(required = false) String username,\n            @RequestParam(required = false) String email,\n            @RequestParam(required = false) String password) {\n        return sqlInjectionTestService.updateUserDynamicSafe(id, username, email, password);\n    }\n\n    /**\n     * 测试用例27：使用MyBatis XML - DELETE条件 - 安全实现\n     */\n    @DeleteMapping("/27")\n    public int testCase27(@RequestParam Integer id) {\n        return sqlInjectionTestService.deleteUsersSafe(id);\n    }\n\n    /**\n     * 测试用例28：使用MyBatis注解 - 安全实现\n     */\n    @GetMapping("/28")\n    public User testCase28(@RequestParam String email) {\n        return sqlInjectionTestService.findUserByEmailSafe(email);\n    }\n\n    /**\n     * 测试用例29：使用MyBatis注解 - 多参数 - 安全实现\n     */\n    @GetMapping("/29")\n    public User testCase29(@RequestParam String username, @RequestParam String password) {\n        return sqlInjectionTestService.findUserByCredentialsSafe(username, password);\n    }\n\n    /**\n     * 测试用例30：使用MyBatis注解 - LIKE查询 - 安全实现\n     */\n    @GetMapping("/30")\n    public List<User> testCase30(@RequestParam String column, @RequestParam String value) {\n        return sqlInjectionTestService.searchUsersSafe(column, value);\n    }\n\n    /**\n     * 测试用例31：原生JDBC - 安全实现\n     */\n    @GetMapping("/31")\n    public List<Map<String, Object>> testCase31(@RequestParam String username, @RequestParam String email) {\n        return sqlInjectionTestService.findUsersByJdbcSafe(username, email);\n    }\n\n    /**\n     * 测试用例32：配置模板字符串 - 安全实现\n     */\n    @GetMapping("/32")\n    public List<Map<String, Object>> testCase32(@RequestParam String username) {\n        return sqlInjectionTestService.findUsersByTemplateSafe(username);\n    }\n\n    /**\n     * 测试用例33：NamedParameterJdbcTemplate - 安全实现\n     */\n    @GetMapping("/33")\n    public List<Map<String, Object>> testCase33(@RequestParam String username, @RequestParam String email) {\n        Map<String, Object> params = new HashMap<>();\n        params.put("username", username);\n        params.put("email", email);\n        return sqlInjectionTestService.findByNamedParamsSafe(params);\n    }\n\n    /**\n     * 测试用例34：使用AOP切面 - 安全实现\n     */\n    @GetMapping("/34")\n    public List<Map<String, Object>> testCase34(@RequestParam String username) {\n        return sqlInjectionTestService.findUsersByAspectSafe(username);\n    }\n\n    /**\n     * 测试用例35：使用预处理语句 - 安全实现\n     */\n    @GetMapping("/35")\n    public List<Map<String, Object>> testCase35(@RequestParam String username, @RequestParam String email) {\n        Map<String, Object> params = new HashMap<>();\n        params.put("username", username);\n        params.put("email", email);\n        return sqlInjectionTestService.findByNamedParamsSafe(params);\n    }\n\n    /**\n     * 测试用例36：使用ORM框架安全特性 - 安全实现\n     */\n    @GetMapping("/36")\n    public List<User> testCase36(\n            @RequestParam(required = false) Integer id,\n            @RequestParam(required = false) String username,\n            @RequestParam(required = false) String email) {\n        return sqlInjectionTestService.findUsersByMultipleConditionsSafe(id, username, email);\n    }\n\n    /**\n     * 测试用例37：使用白名单校验 - 安全实现\n     */\n    @GetMapping("/37")\n    public List<User> testCase37(@RequestParam String sortField) {\n        // 白名单验证\n        List<String> allowedFields = List.of("id", "username", "email");\n        if (!allowedFields.contains(sortField)) {\n            sortField = "id"; // 默认排序字段\n        }\n        return sqlInjectionTestService.findUsersSortedSafe(sortField);\n    }\n\n    /**\n     * 测试用例38：使用参数化查询和类型转换 - 安全实现\n     */\n    @GetMapping("/38")\n    public List<User> testCase38(@RequestParam String limitStr, @RequestParam String offsetStr) {\n        // 类型转换和边界检查\n        int limit;\n        int offset;\n        try {\n            limit = Integer.parseInt(limitStr);\n            offset = Integer.parseInt(offsetStr);\n        } catch (NumberFormatException e) {\n            limit = 10;\n            offset = 0;\n        }\n\n        if (limit <= 0 || limit > 100) limit = 10;\n        if (offset < 0) offset = 0;\n\n        return sqlInjectionTestService.findUsersWithLimitSafe(limit, offset);\n    }\n\n    /**\n     * 测试用例39：使用参数绑定的IN查询 - 安全实现\n     */\n    @GetMapping("/39")\n    public List<User> testCase39(@RequestParam String idsStr) {\n        // 解析ID列表并进行类型转换\n        List<Integer> idList = new ArrayList<>();\n        String[] idsArray = idsStr.split(",");\n        for (String idStr : idsArray) {\n            try {\n                idList.add(Integer.parseInt(idStr.trim()));\n            } catch (NumberFormatException e) {\n                // 忽略非数字输入\n            }\n        }\n        return sqlInjectionTestService.findUsersInListSafe(idList);\n    }\n\n    /**\n     * 测试用例40：组合多种安全方式 - 安全实现\n     */\n    @GetMapping("/40")\n    public List<User> testCase40(\n            @RequestParam(required = false) Integer id,\n            @RequestParam(required = false) String username,\n            @RequestParam(required = false) String email,\n            @RequestParam(required = false) String sortField) {\n\n        // 白名单验证排序字段\n        List<String> allowedFields = List.of("id", "username", "email");\n        if (sortField != null && !allowedFields.contains(sortField)) {\n            sortField = "id"; // 默认排序字段\n        }\n\n        // 安全方式查询\n        List<User> users = sqlInjectionTestService.findUsersByMultipleConditionsSafe(id, username, email);\n\n        // 如果需要排序，可以在应用层进行排序\n        if (sortField != null) {\n            if (sortField.equals("username")) {\n                users.sort((a, b) -> a.getUsername().compareTo(b.getUsername()));\n            } else if (sortField.equals("email")) {\n                users.sort((a, b) -> {\n                    if (a.getEmail() == null) return -1;\n                    if (b.getEmail() == null) return 1;\n                    return a.getEmail().compareTo(b.getEmail());\n                });\n            } else {\n                users.sort((a, b) -> a.getId().compareTo(b.getId()));\n            }\n        }\n\n        return users;\n    }\n\n    /**\n     * 测试用例41：测试更新后的AOP切面 - 不安全实现\n     */\n    @GetMapping("/41")\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "使用更新后的@Before切面实现的不安全SQL查询",\n            remediation = "使用参数化查询和参数绑定",\n            level = VulnerabilityLevel.HIGH,\n            isRealVulnerability = true\n    )\n    public List<Map<String, Object>> testCase41(@RequestParam String username) {\n        return sqlInjectionTestService.testAspectUnsafeMethod(username);\n    }\n\n    /**\n     * 测试用例42：测试更新后的AOP切面 - 安全实现\n     */\n    @GetMapping("/42")\n    public List<Map<String, Object>> testCase42(@RequestParam String username) {\n        return sqlInjectionTestService.testAspectSafeMethod(username);\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 21104, 'completion_tokens': 7595, 'total_tokens': 28699}}
-----------

package edu.thu.benchmark.annotated.controller;

import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import edu.thu.benchmark.annotated.entity.User;
import edu.thu.benchmark.annotated.service.SqlInjectionTestService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * SQL注入测试控制器
 * 包含40个测试用例，20个正例（存在漏洞）和20个负例（安全实现）
 */
@RestController
@RequestMapping("/sqli")
public class SqlInjectionTestController {

    // 原注解: @Autowired
    private SqlInjectionTestService sqlInjectionTestService = new SqlInjectionTestService();
    // TODO 如果不还原语义,那么sql注入将无法检测,因为sqlInjectionTestService被认为是null

    // 原注解: @Autowired
    private JdbcTemplate jdbcTemplate = new JdbcTemplate();
    // ======== 测试用例 - 正例（存在SQL注入漏洞） ========

    /**
     * 测试用例1：使用MyBatis XML - LIKE查询 - 不安全实现
     */
    @GetMapping("/01")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "使用MyBatis XML中的${username}进行字符串拼接，导致SQL注入漏洞",
            remediation = "使用#{username}参数绑定代替${username}字符串拼接",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<Map<String,Object>> testCase01(@RequestParam String username) {
        return sqlInjectionTestService.findUsersByJdbcUnsafe(username);
    }



    /**
     * 测试用例2：使用MyBatis XML - ORDER BY子句 - 不安全实现
     */
    @GetMapping("/02")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在ORDER BY子句中使用${sortField}进行字符串拼接，允许注入额外的SQL语句",
            remediation = "使用白名单验证排序字段或使用预编译语句",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public List<User> testCase02(@RequestParam String sortField) {
        return sqlInjectionTestService.findUsersSortedUnsafe(sortField);
    }

    /**
     * 测试用例3：使用MyBatis XML - IN子句 - 不安全实现
     */
    @GetMapping("/03")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在IN子句中使用${idList}进行字符串拼接，允许任意SQL注入",
            remediation = "使用<foreach>元素或预处理语句构建IN子句",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<User> testCase03(@RequestParam String idList) {
        return sqlInjectionTestService.findUsersInListUnsafe(idList);
    }

    /**
     * 测试用例4：使用MyBatis XML - WHERE子句 - 不安全实现
     */
    @GetMapping("/04")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在WHERE子句中使用${whereClause}进行字符串拼接，允许任意SQL注入",
            remediation = "使用<where>和<if>元素构建动态查询条件",
            level = VulnerabilityLevel.CRITICAL,
            isRealVulnerability = true
    )
    public List<User> testCase04(@RequestParam String whereClause) {
        return sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(whereClause);
    }

    /**
     * 测试用例5：使用MyBatis XML - LIMIT/OFFSET - 不安全实现
     */
    @GetMapping("/05")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在LIMIT和OFFSET子句中使用${limit}和${offset}进行字符串拼接，允许SQL注入",
            remediation = "使用#{limit}和#{offset}参数绑定，并验证输入是否为数字",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public List<User> testCase05(@RequestParam String limit, @RequestParam String offset) {
        return sqlInjectionTestService.findUsersWithLimitUnsafe(limit, offset);
    }

    /**
     * 测试用例6：使用MyBatis XML - SET子句 - 不安全实现
     */
    @PostMapping("/06")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在UPDATE语句的SET子句中使用${setClause}进行字符串拼接，允许任意SQL注入",
            remediation = "使用<set>和<if>元素构建动态更新语句",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public int testCase06(@RequestParam int id, @RequestParam String setClause) {
        return sqlInjectionTestService.updateUserDynamicUnsafe(id, setClause);
    }

    /**
     * 测试用例7：使用MyBatis XML - DELETE条件 - 不安全实现
     */
    @DeleteMapping("/07")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在DELETE语句的WHERE子句中使用${condition}进行字符串拼接，允许任意SQL注入",
            remediation = "使用参数绑定和预编译语句执行删除操作",
            level = VulnerabilityLevel.CRITICAL,
            isRealVulnerability = true
    )
    public int testCase07(@RequestParam String condition) {
        return sqlInjectionTestService.deleteUsersUnsafe(condition);
    }

    /**
     * 测试用例8：使用MyBatis注解 - 不安全实现
     */
    @GetMapping("/08")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在@Select注解中使用${email}进行字符串拼接，允许SQL注入",
            remediation = "使用#{email}参数绑定代替${email}字符串拼接",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public User testCase08(@RequestParam String email) {
        return sqlInjectionTestService.findUserByEmailUnsafe(email);
    }

    /**
     * 测试用例9：使用MyBatis注解 - 多参数 - 不安全实现
     */
    @GetMapping("/09")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在@Select注解中对多个参数使用${username}和${password}进行字符串拼接，导致SQL注入",
            remediation = "使用#{username}和#{password}参数绑定代替字符串拼接",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public User testCase09(@RequestParam String username, @RequestParam String password) {
        return sqlInjectionTestService.findUserByCredentialsUnsafe(username, password);
    }

    /**
     * 测试用例10：使用MyBatis注解 - LIKE查询 - 不安全实现
     */
    @GetMapping("/10")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在@Select注解的LIKE子句中使用${column}和${value}进行字符串拼接，允许SQL注入",
            remediation = "使用白名单验证列名，并使用参数绑定处理LIKE模式",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<User> testCase10(@RequestParam String column, @RequestParam String value) {
        return sqlInjectionTestService.searchUsersUnsafe(column, value);
    }

    /**
     * 测试用例11：原生JDBC - 不安全实现
     */
    @GetMapping("/11")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "使用JDBC直接拼接查询条件，允许任意SQL注入",
            remediation = "使用PreparedStatement和参数绑定",
            level = VulnerabilityLevel.CRITICAL,
            isRealVulnerability = true
    )
    public List<Map<String, Object>> testCase11(@RequestParam String condition) {
        return sqlInjectionTestService.findUsersByJdbcUnsafe(condition);
    }

    /**
     * 测试用例12：配置模板字符串 - 不安全实现
     */
    @GetMapping("/12")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "使用来自配置文件的SQL模板和String.format()进行字符串拼接，允许SQL注入",
            remediation = "使用PreparedStatement和参数绑定代替String.format()",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<Map<String, Object>> testCase12(@RequestParam String username) {
        return sqlInjectionTestService.findUsersByTemplateUnsafe(username);
    }

    /**
     * 测试用例13：NamedParameterJdbcTemplate - 不安全实现
     */
    @GetMapping("/13")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "使用NamedParameterJdbcTemplate但仍然拼接WHERE子句，允许SQL注入",
            remediation = "所有SQL语句都应使用参数化查询，不进行直接拼接",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<Map<String, Object>> testCase13(@RequestParam String whereClause) {
        Map<String, Object> params = new HashMap<>();
        params.put("username", "admin");
        params.put("email", "admin@example.com");
        return sqlInjectionTestService.findByNamedParamsUnsafe(whereClause, params);
    }

    /**
     * 测试用例14：使用AOP切面 - 不安全实现
     */
    @GetMapping("/14")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "通过AOP切面执行SQL时使用字符串替换而非参数绑定，允许SQL注入",
            remediation = "使用PreparedStatement和参数绑定代替字符串替换",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<Map<String, Object>> testCase14(@RequestParam String username) {
        return sqlInjectionTestService.findUsersByAspectUnsafe(username);
    }

    /**
     * 测试用例15：MyBatis XML - LIKE查询 - 半安全实现
     */
    @GetMapping("/15")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "在LIKE子句中正确使用参数绑定，但列名仍然使用${column}字符串拼接，允许列名注入",
            remediation = "使用白名单验证列名，避免拼接列名",
            level = VulnerabilityLevel.MEDIUM,
            isRealVulnerability = true
    )
    public List<User> testCase15(@RequestParam String column, @RequestParam String value) {
        return sqlInjectionTestService.searchUsersSemiSafe(column, value);
    }

    /**
     * 测试用例16：字符串拼接多个条件 - 不安全实现
     */
    @GetMapping("/16")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "手动拼接多个查询条件，允许SQL注入",
            remediation = "使用参数化查询和动态SQL构建条件",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<User> testCase16(@RequestParam String id, @RequestParam String username) {
        String whereClause = "id = " + id + " OR username LIKE '%" + username + "%'";
        return sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(whereClause);
    }

    /**
     * 测试用例17：字符串模板内联SQL - 不安全实现
     */
    @GetMapping("/17")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "使用Java字符串模板进行SQL拼接，允许SQL注入",
            remediation = "使用参数化查询替代字符串模板",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<Map<String, Object>> testCase17(@RequestParam String id, @RequestParam String username) {
        String condition = "id = " + id + " OR username = '" + username + "'";
        return sqlInjectionTestService.findUsersByJdbcUnsafe(condition);
    }

    /**
     * 测试用例18：自定义SQL拼接 - 不安全实现
     */
    @GetMapping("/18")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "手动构建复杂的WHERE子句，允许SQL注入",
            remediation = "使用参数化查询和ORM框架的动态SQL功能",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<User> testCase18(
            @RequestParam(required = false) String username,
            @RequestParam(required = false) String email,
            @RequestParam(required = false) String sortBy) {
        StringBuilder whereClause = new StringBuilder();
        if (username != null) {
            whereClause.append("username LIKE '%").append(username).append("%'");
        }
        if (email != null) {
            if (whereClause.length() > 0) {
                whereClause.append(" AND ");
            }
            whereClause.append("email LIKE '%").append(email).append("%'");
        }
        if (sortBy != null) {
            whereClause.append(" ORDER BY ").append(sortBy);
        }
        return sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(whereClause.toString());
    }

    /**
     * 测试用例19：使用不同的拼接方式 - 不安全实现
     */
    @GetMapping("/19")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "使用+运算符拼接SQL语句，允许SQL注入",
            remediation = "使用参数化查询和参数绑定",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public User testCase19(@RequestParam String id) {
        String condition = "id = " + id;
        List<User> users = sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(condition);
        return users.isEmpty() ? null : users.get(0);
    }

    /**
     * 测试用例20：组合多种不安全方式 - 不安全实现
     */
    @GetMapping("/20")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "组合多种不安全的SQL拼接方式，允许复杂的SQL注入",
            remediation = "使用参数化查询和ORM框架的安全特性",
            level = VulnerabilityLevel.CRITICAL,
            isRealVulnerability = true
    )
    public List<User> testCase20(
            @RequestParam String field,
            @RequestParam String value,
            @RequestParam String orderBy,
            @RequestParam String limit) {
        String whereClause = field + " = '" + value + "' ORDER BY " + orderBy + " LIMIT " + limit;
        return sqlInjectionTestService.findUsersByMultipleConditionsUnsafe(whereClause);
    }

    // ======== 测试用例 - 负例（安全实现） ========

    /**
     * 测试用例21：使用MyBatis XML - LIKE查询 - 安全实现
     */
    @GetMapping("/21")
    public List<User> testCase21(@RequestParam String username) {
        return sqlInjectionTestService.findUsersByNameSafe(username);
    }

    /**
     * 测试用例22：使用MyBatis XML - ORDER BY子句 - 安全实现
     */
    @GetMapping("/22")
    public List<User> testCase22(@RequestParam String sortField) {
        return sqlInjectionTestService.findUsersSortedSafe(sortField);
    }

    /**
     * 测试用例23：使用MyBatis XML - IN子句 - 安全实现
     */
    @GetMapping("/23")
    public List<User> testCase23(@RequestParam List<Integer> idList) {
        return sqlInjectionTestService.findUsersInListSafe(idList);
    }

    /**
     * 测试用例24：使用MyBatis XML - 多条件查询 - 安全实现
     */
    @GetMapping("/24")
    public List<User> testCase24(
            @RequestParam(required = false) Integer id,
            @RequestParam(required = false) String username,
            @RequestParam(required = false) String email) {
        return sqlInjectionTestService.findUsersByMultipleConditionsSafe(id, username, email);
    }

    /**
     * 测试用例25：使用MyBatis XML - LIMIT/OFFSET - 安全实现
     */
    @GetMapping("/25")
    public List<User> testCase25(@RequestParam int limit, @RequestParam int offset) {
        return sqlInjectionTestService.findUsersWithLimitSafe(limit, offset);
    }

    /**
     * 测试用例26：使用MyBatis XML - SET子句 - 安全实现
     */
    @PostMapping("/26")
    public int testCase26(
            @RequestParam int id,
            @RequestParam(required = false) String username,
            @RequestParam(required = false) String email,
            @RequestParam(required = false) String password) {
        return sqlInjectionTestService.updateUserDynamicSafe(id, username, email, password);
    }

    /**
     * 测试用例27：使用MyBatis XML - DELETE条件 - 安全实现
     */
    @DeleteMapping("/27")
    public int testCase27(@RequestParam Integer id) {
        return sqlInjectionTestService.deleteUsersSafe(id);
    }

    /**
     * 测试用例28：使用MyBatis注解 - 安全实现
     */
    @GetMapping("/28")
    public User testCase28(@RequestParam String email) {
        return sqlInjectionTestService.findUserByEmailSafe(email);
    }

    /**
     * 测试用例29：使用MyBatis注解 - 多参数 - 安全实现
     */
    @GetMapping("/29")
    public User testCase29(@RequestParam String username, @RequestParam String password) {
        return sqlInjectionTestService.findUserByCredentialsSafe(username, password);
    }

    /**
     * 测试用例30：使用MyBatis注解 - LIKE查询 - 安全实现
     */
    @GetMapping("/30")
    public List<User> testCase30(@RequestParam String column, @RequestParam String value) {
        return sqlInjectionTestService.searchUsersSafe(column, value);
    }

    /**
     * 测试用例31：原生JDBC - 安全实现
     */
    @GetMapping("/31")
    public List<Map<String, Object>> testCase31(@RequestParam String username, @RequestParam String email) {
        return sqlInjectionTestService.findUsersByJdbcSafe(username, email);
    }

    /**
     * 测试用例32：配置模板字符串 - 安全实现
     */
    @GetMapping("/32")
    public List<Map<String, Object>> testCase32(@RequestParam String username) {
        return sqlInjectionTestService.findUsersByTemplateSafe(username);
    }

    /**
     * 测试用例33：NamedParameterJdbcTemplate - 安全实现
     */
    @GetMapping("/33")
    public List<Map<String, Object>> testCase33(@RequestParam String username, @RequestParam String email) {
        Map<String, Object> params = new HashMap<>();
        params.put("username", username);
        params.put("email", email);
        return sqlInjectionTestService.findByNamedParamsSafe(params);
    }

    /**
     * 测试用例34：使用AOP切面 - 安全实现
     */
    @GetMapping("/34")
    public List<Map<String, Object>> testCase34(@RequestParam String username) {
        return sqlInjectionTestService.findUsersByAspectSafe(username);
    }

    /**
     * 测试用例35：使用预处理语句 - 安全实现
     */
    @GetMapping("/35")
    public List<Map<String, Object>> testCase35(@RequestParam String username, @RequestParam String email) {
        Map<String, Object> params = new HashMap<>();
        params.put("username", username);
        params.put("email", email);
        return sqlInjectionTestService.findByNamedParamsSafe(params);
    }

    /**
     * 测试用例36：使用ORM框架安全特性 - 安全实现
     */
    @GetMapping("/36")
    public List<User> testCase36(
            @RequestParam(required = false) Integer id,
            @RequestParam(required = false) String username,
            @RequestParam(required = false) String email) {
        return sqlInjectionTestService.findUsersByMultipleConditionsSafe(id, username, email);
    }

    /**
     * 测试用例37：使用白名单校验 - 安全实现
     */
    @GetMapping("/37")
    public List<User> testCase37(@RequestParam String sortField) {
        // 白名单验证
        List<String> allowedFields = List.of("id", "username", "email");
        if (!allowedFields.contains(sortField)) {
            sortField = "id"; // 默认排序字段
        }
        return sqlInjectionTestService.findUsersSortedSafe(sortField);
    }

    /**
     * 测试用例38：使用参数化查询和类型转换 - 安全实现
     */
    @GetMapping("/38")
    public List<User> testCase38(@RequestParam String limitStr, @RequestParam String offsetStr) {
        // 类型转换和边界检查
        int limit;
        int offset;
        try {
            limit = Integer.parseInt(limitStr);
            offset = Integer.parseInt(offsetStr);
        } catch (NumberFormatException e) {
            limit = 10;
            offset = 0;
        }

        if (limit <= 0 || limit > 100) limit = 10;
        if (offset < 0) offset = 0;

        return sqlInjectionTestService.findUsersWithLimitSafe(limit, offset);
    }

    /**
     * 测试用例39：使用参数绑定的IN查询 - 安全实现
     */
    @GetMapping("/39")
    public List<User> testCase39(@RequestParam String idsStr) {
        // 解析ID列表并进行类型转换
        List<Integer> idList = new ArrayList<>();
        String[] idsArray = idsStr.split(",");
        for (String idStr : idsArray) {
            try {
                idList.add(Integer.parseInt(idStr.trim()));
            } catch (NumberFormatException e) {
                // 忽略非数字输入
            }
        }
        return sqlInjectionTestService.findUsersInListSafe(idList);
    }

    /**
     * 测试用例40：组合多种安全方式 - 安全实现
     */
    @GetMapping("/40")
    public List<User> testCase40(
            @RequestParam(required = false) Integer id,
            @RequestParam(required = false) String username,
            @RequestParam(required = false) String email,
            @RequestParam(required = false) String sortField) {

        // 白名单验证排序字段
        List<String> allowedFields = List.of("id", "username", "email");
        if (sortField != null && !allowedFields.contains(sortField)) {
            sortField = "id"; // 默认排序字段
        }

        // 安全方式查询
        List<User> users = sqlInjectionTestService.findUsersByMultipleConditionsSafe(id, username, email);

        // 如果需要排序，可以在应用层进行排序
        if (sortField != null) {
            if (sortField.equals("username")) {
                users.sort((a, b) -> a.getUsername().compareTo(b.getUsername()));
            } else if (sortField.equals("email")) {
                users.sort((a, b) -> {
                    if (a.getEmail() == null) return -1;
                    if (b.getEmail() == null) return 1;
                    return a.getEmail().compareTo(b.getEmail());
                });
            } else {
                users.sort((a, b) -> a.getId().compareTo(b.getId()));
            }
        }

        return users;
    }

    /**
     * 测试用例41：测试更新后的AOP切面 - 不安全实现
     */
    @GetMapping("/41")
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "使用更新后的@Before切面实现的不安全SQL查询",
            remediation = "使用参数化查询和参数绑定",
            level = VulnerabilityLevel.HIGH,
            isRealVulnerability = true
    )
    public List<Map<String, Object>> testCase41(@RequestParam String username) {
        return sqlInjectionTestService.testAspectUnsafeMethod(username);
    }

    /**
     * 测试用例42：测试更新后的AOP切面 - 安全实现
     */
    @GetMapping("/42")
    public List<Map<String, Object>> testCase42(@RequestParam String username) {
        return sqlInjectionTestService.testAspectSafeMethod(username);
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/UserController.java
2025-03-25 23:18:41,098 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
2025-03-25 23:19:06,393 - llm_client - WARNING - 请求失败 (尝试 1/3): 没有choice返回
2025-03-25 23:19:06,393 - llm_client - INFO - 等待 5 秒后重试...
{'id': 'gen-1742915944-zT6jcG2Gb6q5cH03ThqT', 'provider': 'Anthropic', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915944, 'choices': []}
{'id': 'gen-1742915952-25TsAzvbTEACy451KWLL', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742915952, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.controller;\n\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport edu.thu.benchmark.annotated.entity.User;\nimport edu.thu.benchmark.annotated.service.UserService;\nimport edu.thu.benchmark.annotated.service.impl.UserServiceImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.List;\n\n/**\n * 用户控制器\n * 包含XSS和SQL注入漏洞示例\n */\n@Controller\n@RequestMapping("/users")\npublic class UserController {\n\n    // 原注解: @Autowired\n    private UserService userService = new UserServiceImpl();\n\n    /**\n     * 查询所有用户\n     */\n    @GetMapping\n    public String getAllUsers(Model model) {\n        List<User> users = userService.getAllUsers();\n        model.addAttribute("users", users);\n        return "user/list";\n    }\n\n    /**\n     * 根据ID查询用户\n     */\n    @GetMapping("/{id}")\n    public String getUserById(@PathVariable Integer id, Model model) {\n        User user = userService.getUserById(id);\n        model.addAttribute("user", user);\n        return "user/detail";\n    }\n\n    /**\n     * 根据用户名查询用户\n     * 存在XSS漏洞 - 未对输入输出进行过滤\n     */\n    @Vulnerability(\n            cwe = 79,\n            type = VulnerabilityType.XSS,\n            description = "直接将用户输入数据未经过滤输出到页面",\n            remediation = "使用Spring的th:text或使用HTML编码函数处理输出数据",\n            level = VulnerabilityLevel.HIGH\n    )\n    @GetMapping("/search")\n    public void searchByUsername(@RequestParam String username, HttpServletResponse response) throws IOException {\n        User user = userService.getUserByUsername(username);\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n\n        // 不安全的输出方式，存在XSS漏洞\n        out.println("<html><body>");\n        if (user != null) {\n            out.println("<h2>用户信息:</h2>");\n            out.println("<p>你搜索的用户名: " + username + "</p>");\n            out.println("<p>ID: " + user.getId() + "</p>");\n            out.println("<p>用户名: " + user.getUsername() + "</p>");\n            out.println("<p>邮箱: " + user.getEmail() + "</p>");\n        } else {\n            out.println("<p>未找到用户名为 " + username + " 的用户</p>");\n        }\n        out.println("</body></html>");\n        out.close();\n    }\n\n    /**\n     * 根据邮箱查询用户\n     * 存在SQL注入漏洞 - 直接将用户输入拼接到SQL语句中\n     */\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "通过MyBatis的${email}直接将用户输入拼接到SQL语句中",\n            remediation = "使用参数化查询 #{email} 替代字符串拼接 ${email}",\n            level = VulnerabilityLevel.CRITICAL\n    )\n    @GetMapping("/findByEmail")\n    public String findByEmail(@RequestParam String email, Model model) {\n        User user = userService.getUserByEmail(email);\n        model.addAttribute("user", user);\n        model.addAttribute("email", email);\n        return "user/detail";\n    }\n\n    /**\n     * 根据条件查询用户\n     * 存在SQL注入漏洞\n     */\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "直接将用户输入作为SQL条件语句",\n            remediation = "使用预编译语句和参数化查询，不要直接拼接SQL语句",\n            level = VulnerabilityLevel.CRITICAL\n    )\n    @GetMapping("/findByCondition")\n    @ResponseBody\n    public List<User> findByCondition(@RequestParam String condition) {\n        return userService.findUsersByCondition(condition);\n    }\n\n    /**\n     * 添加用户表单页面\n     */\n    @GetMapping("/add")\n    public String addUserForm(Model model) {\n        model.addAttribute("user", new User());\n        return "user/add";\n    }\n\n    /**\n     * 添加用户处理\n     */\n    @PostMapping("/add")\n    public String addUser(@ModelAttribute User user) {\n        userService.insertUser(user);\n        return "redirect:/users";\n    }\n\n    /**\n     * 更新用户信息\n     * 存在SQL注入漏洞\n     */\n    @Vulnerability(\n            cwe = 89,\n            type = VulnerabilityType.SQL_INJECTION,\n            description = "直接将用户输入拼接到SQL更新语句中",\n            remediation = "使用参数化更新语句，如PreparedStatement",\n            level = VulnerabilityLevel.HIGH\n    )\n    @PostMapping("/update/{id}")\n    @ResponseBody\n    public String updateUser(@PathVariable Integer id, @RequestParam String fields) {\n        int result = userService.updateUser(id, fields);\n        return result > 0 ? "更新成功" : "更新失败";\n    }\n\n    /**\n     * 删除用户\n     */\n    @GetMapping("/delete/{id}")\n    public String deleteUser(@PathVariable Integer id) {\n        userService.deleteUser(id);\n        return "redirect:/users";\n    }\n\n    /**\n     * 反射型XSS漏洞示例\n     */\n    @Vulnerability(\n            cwe = 79,\n            type = VulnerabilityType.XSS,\n            description = "URL参数未经过滤直接反射到页面",\n            remediation = "对输出到HTML页面的内容进行HTML编码",\n            level = VulnerabilityLevel.MEDIUM\n    )\n    @GetMapping("/welcome")\n    public void welcome(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String name = request.getParameter("name");\n        response.setContentType("text/html;charset=UTF-8");\n        PrintWriter out = response.getWriter();\n\n        // 不安全的输出方式，存在反射型XSS漏洞\n        out.println("<html><body>");\n        out.println("<h1>欢迎, " + name + "!</h1>");\n        out.println("</body></html>");\n        out.close();\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 10280, 'completion_tokens': 1901, 'total_tokens': 12181}}
-----------

package edu.thu.benchmark.annotated.controller;

import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import edu.thu.benchmark.annotated.entity.User;
import edu.thu.benchmark.annotated.service.UserService;
import edu.thu.benchmark.annotated.service.impl.UserServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

/**
 * 用户控制器
 * 包含XSS和SQL注入漏洞示例
 */
@Controller
@RequestMapping("/users")
public class UserController {

    // 原注解: @Autowired
    private UserService userService = new UserServiceImpl();

    /**
     * 查询所有用户
     */
    @GetMapping
    public String getAllUsers(Model model) {
        List<User> users = userService.getAllUsers();
        model.addAttribute("users", users);
        return "user/list";
    }

    /**
     * 根据ID查询用户
     */
    @GetMapping("/{id}")
    public String getUserById(@PathVariable Integer id, Model model) {
        User user = userService.getUserById(id);
        model.addAttribute("user", user);
        return "user/detail";
    }

    /**
     * 根据用户名查询用户
     * 存在XSS漏洞 - 未对输入输出进行过滤
     */
    @Vulnerability(
            cwe = 79,
            type = VulnerabilityType.XSS,
            description = "直接将用户输入数据未经过滤输出到页面",
            remediation = "使用Spring的th:text或使用HTML编码函数处理输出数据",
            level = VulnerabilityLevel.HIGH
    )
    @GetMapping("/search")
    public void searchByUsername(@RequestParam String username, HttpServletResponse response) throws IOException {
        User user = userService.getUserByUsername(username);
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();

        // 不安全的输出方式，存在XSS漏洞
        out.println("<html><body>");
        if (user != null) {
            out.println("<h2>用户信息:</h2>");
            out.println("<p>你搜索的用户名: " + username + "</p>");
            out.println("<p>ID: " + user.getId() + "</p>");
            out.println("<p>用户名: " + user.getUsername() + "</p>");
            out.println("<p>邮箱: " + user.getEmail() + "</p>");
        } else {
            out.println("<p>未找到用户名为 " + username + " 的用户</p>");
        }
        out.println("</body></html>");
        out.close();
    }

    /**
     * 根据邮箱查询用户
     * 存在SQL注入漏洞 - 直接将用户输入拼接到SQL语句中
     */
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "通过MyBatis的${email}直接将用户输入拼接到SQL语句中",
            remediation = "使用参数化查询 #{email} 替代字符串拼接 ${email}",
            level = VulnerabilityLevel.CRITICAL
    )
    @GetMapping("/findByEmail")
    public String findByEmail(@RequestParam String email, Model model) {
        User user = userService.getUserByEmail(email);
        model.addAttribute("user", user);
        model.addAttribute("email", email);
        return "user/detail";
    }

    /**
     * 根据条件查询用户
     * 存在SQL注入漏洞
     */
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "直接将用户输入作为SQL条件语句",
            remediation = "使用预编译语句和参数化查询，不要直接拼接SQL语句",
            level = VulnerabilityLevel.CRITICAL
    )
    @GetMapping("/findByCondition")
    @ResponseBody
    public List<User> findByCondition(@RequestParam String condition) {
        return userService.findUsersByCondition(condition);
    }

    /**
     * 添加用户表单页面
     */
    @GetMapping("/add")
    public String addUserForm(Model model) {
        model.addAttribute("user", new User());
        return "user/add";
    }

    /**
     * 添加用户处理
     */
    @PostMapping("/add")
    public String addUser(@ModelAttribute User user) {
        userService.insertUser(user);
        return "redirect:/users";
    }

    /**
     * 更新用户信息
     * 存在SQL注入漏洞
     */
    @Vulnerability(
            cwe = 89,
            type = VulnerabilityType.SQL_INJECTION,
            description = "直接将用户输入拼接到SQL更新语句中",
            remediation = "使用参数化更新语句，如PreparedStatement",
            level = VulnerabilityLevel.HIGH
    )
    @PostMapping("/update/{id}")
    @ResponseBody
    public String updateUser(@PathVariable Integer id, @RequestParam String fields) {
        int result = userService.updateUser(id, fields);
        return result > 0 ? "更新成功" : "更新失败";
    }

    /**
     * 删除用户
     */
    @GetMapping("/delete/{id}")
    public String deleteUser(@PathVariable Integer id) {
        userService.deleteUser(id);
        return "redirect:/users";
    }

    /**
     * 反射型XSS漏洞示例
     */
    @Vulnerability(
            cwe = 79,
            type = VulnerabilityType.XSS,
            description = "URL参数未经过滤直接反射到页面",
            remediation = "对输出到HTML页面的内容进行HTML编码",
            level = VulnerabilityLevel.MEDIUM
    )
    @GetMapping("/welcome")
    public void welcome(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String name = request.getParameter("name");
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();

        // 不安全的输出方式，存在反射型XSS漏洞
        out.println("<html><body>");
        out.println("<h1>欢迎, " + name + "!</h1>");
        out.println("</body></html>");
        out.close();
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/controller/XmlController.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/controller/XmlController.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/entity/CommandExecution.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/entity/CommandExecution.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/entity/FileInfo.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/entity/FileInfo.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/entity/Product.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/entity/Product.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/entity/User.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/entity/User.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/mapper/UserMapper.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/mapper/UserMapper.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/mapper/UserSqlInjectionMapper.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/mapper/UserSqlInjectionMapper.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/service/CommandService.java
2025-03-25 23:19:36,812 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
2025-03-25 23:20:08,736 - llm_client - WARNING - 请求失败 (尝试 1/3): 没有choice返回
2025-03-25 23:20:08,736 - llm_client - INFO - 等待 5 秒后重试...
{'id': 'gen-1742916007-ELvDkgEb8SS5w2M62ffX', 'provider': 'Anthropic', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742916007, 'choices': []}
{'id': 'gen-1742916014-eEABEjEVt07I1fuqXW8h', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742916014, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.service;\n\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\n/**\n * 命令执行服务\n * 演示如何在服务类中使用@Value注解获取命令执行器配置\n */\n@Service\npublic class CommandService {\n\n    // 直接从配置文件中获取命令执行器\n    // 原注解: @Value("${app.command.executor}")\n    private String commandExecutor = "/bin/bash";\n\n    // 允许执行的命令白名单\n    // 原注解: @Value("${app.command.whitelist}")\n    private String commandWhitelist = "ls,dir,pwd,whoami,date,echo";\n\n    // 参数验证的正则表达式\n    // 原注解: @Value("${app.command.arg-pattern}")\n    private String argPattern = "[a-zA-Z0-9_\\\\-\\\\.]*";\n\n    private static final List<String> ALLOWED_COMMANDS = Arrays.asList("ls", "echo", "cat");\n\n    /**\n     * 不安全的命令执行方法\n     * 直接拼接用户输入作为命令参数\n     */\n    @Vulnerability(\n            cwe = 78,\n            type = VulnerabilityType.COMMAND_INJECTION,\n            description = "直接拼接用户输入作为命令参数，未进行验证",\n            remediation = "验证命令和参数，使用参数数组而非字符串拼接",\n            level = VulnerabilityLevel.CRITICAL\n    )\n    public String executeCommandUnsafe(String command) throws IOException {\n        // 不安全：直接使用用户输入的命令\n        Process process = Runtime.getRuntime().exec(commandExecutor + " -c \\"" + command + "\\"");\n\n        // 读取命令输出\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append("\\n");\n        }\n\n        return output.toString();\n    }\n\n    /**\n     * 安全的命令执行方法\n     * 验证命令和参数，使用参数数组\n     */\n    public String executeCommandSafe(String command) throws IOException {\n        try {\n            String[] parts = command.split("\\\\s+", 2);\n\n            // 验证命令是否在白名单中\n            if (parts.length > 0 && ALLOWED_COMMANDS.contains(parts[0])) {\n                // 验证参数不包含危险字符\n                if (parts.length == 1 || !parts[1].matches(".*[;&|`\\\\\\\\\\"\'$].*")) {\n                    ProcessBuilder processBuilder = new ProcessBuilder();\n                    if (parts.length == 1) {\n                        processBuilder.command(parts[0]);\n                    } else {\n                        processBuilder.command(parts[0], parts[1]);\n                    }\n                    Process process = processBuilder.start();\n                    return readProcessOutput(process);\n                }\n            }\n\n            return "Command not allowed";\n        } catch (IOException e) {\n            return "Error: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 辅助方法：读取进程输出\n     */\n    private String readProcessOutput(Process process) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append("\\n");\n            }\n            return output.toString();\n        }\n    }\n\n    /**\n     * 获取命令执行器\n     */\n    public String getCommandExecutor() {\n        return commandExecutor;\n    }\n\n    /**\n     * 获取命令白名单\n     */\n    public String getCommandWhitelist() {\n        return commandWhitelist;\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 9414, 'completion_tokens': 1174, 'total_tokens': 10588}}
-----------

package edu.thu.benchmark.annotated.service;

import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

/**
 * 命令执行服务
 * 演示如何在服务类中使用@Value注解获取命令执行器配置
 */
@Service
public class CommandService {

    // 直接从配置文件中获取命令执行器
    // 原注解: @Value("${app.command.executor}")
    private String commandExecutor = "/bin/bash";

    // 允许执行的命令白名单
    // 原注解: @Value("${app.command.whitelist}")
    private String commandWhitelist = "ls,dir,pwd,whoami,date,echo";

    // 参数验证的正则表达式
    // 原注解: @Value("${app.command.arg-pattern}")
    private String argPattern = "[a-zA-Z0-9_\\-\\.]*";

    private static final List<String> ALLOWED_COMMANDS = Arrays.asList("ls", "echo", "cat");

    /**
     * 不安全的命令执行方法
     * 直接拼接用户输入作为命令参数
     */
    @Vulnerability(
            cwe = 78,
            type = VulnerabilityType.COMMAND_INJECTION,
            description = "直接拼接用户输入作为命令参数，未进行验证",
            remediation = "验证命令和参数，使用参数数组而非字符串拼接",
            level = VulnerabilityLevel.CRITICAL
    )
    public String executeCommandUnsafe(String command) throws IOException {
        // 不安全：直接使用用户输入的命令
        Process process = Runtime.getRuntime().exec(commandExecutor + " -c \"" + command + "\"");

        // 读取命令输出
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        StringBuilder output = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            output.append(line).append("\n");
        }

        return output.toString();
    }

    /**
     * 安全的命令执行方法
     * 验证命令和参数，使用参数数组
     */
    public String executeCommandSafe(String command) throws IOException {
        try {
            String[] parts = command.split("\\s+", 2);

            // 验证命令是否在白名单中
            if (parts.length > 0 && ALLOWED_COMMANDS.contains(parts[0])) {
                // 验证参数不包含危险字符
                if (parts.length == 1 || !parts[1].matches(".*[;&|`\\\\\"'$].*")) {
                    ProcessBuilder processBuilder = new ProcessBuilder();
                    if (parts.length == 1) {
                        processBuilder.command(parts[0]);
                    } else {
                        processBuilder.command(parts[0], parts[1]);
                    }
                    Process process = processBuilder.start();
                    return readProcessOutput(process);
                }
            }

            return "Command not allowed";
        } catch (IOException e) {
            return "Error: " + e.getMessage();
        }
    }

    /**
     * 辅助方法：读取进程输出
     */
    private String readProcessOutput(Process process) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            StringBuilder output = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
            return output.toString();
        }
    }

    /**
     * 获取命令执行器
     */
    public String getCommandExecutor() {
        return commandExecutor;
    }

    /**
     * 获取命令白名单
     */
    public String getCommandWhitelist() {
        return commandWhitelist;
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/service/FileService.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/service/FileService.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/service/FileUploadService.java
2025-03-25 23:20:31,285 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
2025-03-25 23:20:49,424 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742916033-pO40ZvtIuy9gdwxf8s8a', 'provider': 'Amazon Bedrock', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742916033, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.service;\n\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.UUID;\n\n/**\n * 文件上传服务\n * 演示如何在服务类中使用@Value注解获取配置项\n */\n@Service\npublic class FileUploadService {\n\n    // 原注解: @Value("${app.upload.directory}")\n    private String uploadDirectory = "./uploads";\n\n    // 原注解: @Value("${app.upload.max-size}") // 默认10MB\n    private long maxFileSize = 10485760;\n\n    // 原注解: @Value("${app.upload.allowed-extensions}")\n    private String allowedExtensions = ".jpg,.jpeg,.png,.pdf,.docx";\n\n    /**\n     * 不安全的文件上传方法\n     * 直接使用用户提供的文件名\n     */\n    @Vulnerability(\n            cwe = 434,\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            description = "不安全的文件上传，使用用户提供的文件名，未进行验证",\n            remediation = "验证文件名并使用安全的文件名生成方式",\n            level = VulnerabilityLevel.HIGH\n    )\n    public String saveFileUnsafe(MultipartFile file, String customName) throws IOException {\n        // 创建目录（如果不存在）\n        File directory = new File(uploadDirectory);\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n\n        // 不安全：直接使用用户提供的自定义名称\n        String fileName = customName != null ? customName : file.getOriginalFilename();\n        Path filePath = Paths.get(uploadDirectory, fileName);\n\n        // 保存文件\n        Files.write(filePath, file.getBytes());\n\n        return filePath.toString();\n    }\n\n    /**\n     * 安全的文件上传方法\n     * 使用随机生成的文件名\n     */\n    public String saveFileSafe(MultipartFile file) throws IOException {\n        // 验证文件大小\n        if (file.getSize() > maxFileSize) {\n            throw new IllegalArgumentException("文件大小超过限制");\n        }\n\n        // 验证文件类型\n        String originalFilename = file.getOriginalFilename();\n        if (!isAllowedFileType(originalFilename)) {\n            throw new IllegalArgumentException("不支持的文件类型");\n        }\n\n        // 创建目录（如果不存在）\n        File directory = new File(uploadDirectory);\n        if (!directory.exists()) {\n            directory.mkdirs();\n        }\n\n        // 生成安全的随机文件名，但保留原始扩展名\n        String extension = "";\n        if (originalFilename != null && originalFilename.contains(".")) {\n            extension = originalFilename.substring(originalFilename.lastIndexOf("."));\n        }\n        String safeFileName = UUID.randomUUID().toString() + extension;\n\n        // 保存文件\n        Path filePath = Paths.get(uploadDirectory, safeFileName);\n        Files.write(filePath, file.getBytes());\n\n        return filePath.toString();\n    }\n\n    /**\n     * 检查文件类型是否允许\n     */\n    private boolean isAllowedFileType(String fileName) {\n        if (fileName == null || fileName.isEmpty()) {\n            return false;\n        }\n\n        String extension = fileName.substring(fileName.lastIndexOf(".")).toLowerCase();\n        String[] allowedExtensionArray = allowedExtensions.split(",");\n\n        for (String allowedExt : allowedExtensionArray) {\n            if (extension.equals(allowedExt.trim())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * 获取上传目录\n     */\n    public String getUploadDirectory() {\n        return uploadDirectory;\n    }\n\n    /**\n     * 获取最大文件大小\n     */\n    public long getMaxFileSize() {\n        return maxFileSize;\n    }\n\n    /**\n     * 获取允许的文件扩展名\n     */\n    public String getAllowedExtensions() {\n        return allowedExtensions;\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 9519, 'completion_tokens': 1228, 'total_tokens': 10747}}
-----------

package edu.thu.benchmark.annotated.service;

import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

/**
 * 文件上传服务
 * 演示如何在服务类中使用@Value注解获取配置项
 */
@Service
public class FileUploadService {

    // 原注解: @Value("${app.upload.directory}")
    private String uploadDirectory = "./uploads";

    // 原注解: @Value("${app.upload.max-size}") // 默认10MB
    private long maxFileSize = 10485760;

    // 原注解: @Value("${app.upload.allowed-extensions}")
    private String allowedExtensions = ".jpg,.jpeg,.png,.pdf,.docx";

    /**
     * 不安全的文件上传方法
     * 直接使用用户提供的文件名
     */
    @Vulnerability(
            cwe = 434,
            type = VulnerabilityType.PATH_TRAVERSAL,
            description = "不安全的文件上传，使用用户提供的文件名，未进行验证",
            remediation = "验证文件名并使用安全的文件名生成方式",
            level = VulnerabilityLevel.HIGH
    )
    public String saveFileUnsafe(MultipartFile file, String customName) throws IOException {
        // 创建目录（如果不存在）
        File directory = new File(uploadDirectory);
        if (!directory.exists()) {
            directory.mkdirs();
        }

        // 不安全：直接使用用户提供的自定义名称
        String fileName = customName != null ? customName : file.getOriginalFilename();
        Path filePath = Paths.get(uploadDirectory, fileName);

        // 保存文件
        Files.write(filePath, file.getBytes());

        return filePath.toString();
    }

    /**
     * 安全的文件上传方法
     * 使用随机生成的文件名
     */
    public String saveFileSafe(MultipartFile file) throws IOException {
        // 验证文件大小
        if (file.getSize() > maxFileSize) {
            throw new IllegalArgumentException("文件大小超过限制");
        }

        // 验证文件类型
        String originalFilename = file.getOriginalFilename();
        if (!isAllowedFileType(originalFilename)) {
            throw new IllegalArgumentException("不支持的文件类型");
        }

        // 创建目录（如果不存在）
        File directory = new File(uploadDirectory);
        if (!directory.exists()) {
            directory.mkdirs();
        }

        // 生成安全的随机文件名，但保留原始扩展名
        String extension = "";
        if (originalFilename != null && originalFilename.contains(".")) {
            extension = originalFilename.substring(originalFilename.lastIndexOf("."));
        }
        String safeFileName = UUID.randomUUID().toString() + extension;

        // 保存文件
        Path filePath = Paths.get(uploadDirectory, safeFileName);
        Files.write(filePath, file.getBytes());

        return filePath.toString();
    }

    /**
     * 检查文件类型是否允许
     */
    private boolean isAllowedFileType(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            return false;
        }

        String extension = fileName.substring(fileName.lastIndexOf(".")).toLowerCase();
        String[] allowedExtensionArray = allowedExtensions.split(",");

        for (String allowedExt : allowedExtensionArray) {
            if (extension.equals(allowedExt.trim())) {
                return true;
            }
        }

        return false;
    }

    /**
     * 获取上传目录
     */
    public String getUploadDirectory() {
        return uploadDirectory;
    }

    /**
     * 获取最大文件大小
     */
    public long getMaxFileSize() {
        return maxFileSize;
    }

    /**
     * 获取允许的文件扩展名
     */
    public String getAllowedExtensions() {
        return allowedExtensions;
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/service/PathTraversalService.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/service/PathTraversalService.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/service/SqlInjectionTestService.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/service/SqlInjectionTestService.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/service/SqlInjectionTestService1.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/service/SqlInjectionTestService1.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/service/TemplateService.java
{'id': 'gen-1742916091-aRRP5l4QvBiUd4qLupyX', 'provider': 'Anthropic', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742916091, 'choices': []}
2025-03-25 23:21:32,620 - llm_client - WARNING - 请求失败 (尝试 1/3): 没有choice返回
2025-03-25 23:21:32,620 - llm_client - INFO - 等待 5 秒后重试...
2025-03-25 23:21:56,983 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742916100-EGGDjGxHGblqHkKFsnkg', 'provider': 'Amazon Bedrock', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742916100, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.service;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.regex.Pattern;\n\n/**\n * 模板服务类\n * 用于获取模板文件内容，包含不安全和安全的实现\n */\n@Service\npublic class TemplateService {\n\n    // 原注解: @Value("${template.dir}")\n    private String templateDir = "/tmp/templates";\n\n    // 安全白名单模式，只允许字母、数字、下划线和连字符以及.html扩展名\n    private static final Pattern SAFE_TEMPLATE_PATTERN = Pattern.compile("[a-zA-Z0-9_-]+\\\\.html");\n\n    /**\n     * 不安全的模板获取实现\n     * 直接使用用户提供的模板名而不验证\n     *\n     * @param templateName 模板名称\n     * @return 模板内容\n     */\n    public String getTemplateUnsafe(String templateName) {\n        try {\n            // 不安全：直接拼接模板路径而不验证\n            File templateFile = new File(templateDir, templateName);\n            return new String(Files.readAllBytes(templateFile.toPath()));\n        } catch (IOException e) {\n            return "Error loading template: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 安全的模板获取实现\n     * 验证模板名称并确保访问路径在预期目录内\n     *\n     * @param templateName 模板名称\n     * @return 模板内容\n     */\n    public String getTemplateSafe(String templateName) {\n        // 安全：白名单验证模板名称\n        if (!SAFE_TEMPLATE_PATTERN.matcher(templateName).matches()) {\n            throw new SecurityException("Invalid template name");\n        }\n\n        try {\n            Path basePath = Paths.get(templateDir).toAbsolutePath().normalize();\n            Path templatePath = basePath.resolve(templateName).normalize();\n\n            // 验证模板路径是否在预期目录内\n            if (!templatePath.startsWith(basePath)) {\n                throw new SecurityException("Access to the template is not allowed");\n            }\n\n            if (!Files.isRegularFile(templatePath)) {\n                throw new IOException("Template not found");\n            }\n\n            return new String(Files.readAllBytes(templatePath));\n        } catch (IOException e) {\n            return "Error loading template: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 不安全的多级模板获取实现\n     * 允许用户指定子目录路径\n     *\n     * @param templatePath 模板路径\n     * @return 模板内容\n     */\n    public String getNestedTemplateUnsafe(String templatePath) {\n        try {\n            // 不安全：直接拼接模板路径而不验证，允许用户指定子目录\n            File templateFile = new File(templateDir, templatePath);\n            return new String(Files.readAllBytes(templateFile.toPath()));\n        } catch (IOException e) {\n            return "Error loading template: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 安全的多级模板获取实现\n     * 验证模板路径不包含路径遍历字符\n     *\n     * @param templatePath 模板路径\n     * @return 模板内容\n     */\n    public String getNestedTemplateSafe(String templatePath) {\n        // 安全：验证不包含路径遍历字符\n        if (templatePath.contains("..")) {\n            throw new SecurityException("Invalid template path");\n        }\n\n        try {\n            Path basePath = Paths.get(templateDir).toAbsolutePath().normalize();\n            Path templateFullPath = basePath.resolve(templatePath).normalize();\n\n            // 验证模板路径是否在预期目录内\n            if (!templateFullPath.startsWith(basePath)) {\n                throw new SecurityException("Access to the template is not allowed");\n            }\n\n            if (!Files.isRegularFile(templateFullPath)) {\n                throw new IOException("Template not found");\n            }\n\n            return new String(Files.readAllBytes(templateFullPath));\n        } catch (IOException e) {\n            return "Error loading template: " + e.getMessage();\n        }\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 9302, 'completion_tokens': 1185, 'total_tokens': 10487}}
-----------

package edu.thu.benchmark.annotated.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.regex.Pattern;

/**
 * 模板服务类
 * 用于获取模板文件内容，包含不安全和安全的实现
 */
@Service
public class TemplateService {

    // 原注解: @Value("${template.dir}")
    private String templateDir = "/tmp/templates";

    // 安全白名单模式，只允许字母、数字、下划线和连字符以及.html扩展名
    private static final Pattern SAFE_TEMPLATE_PATTERN = Pattern.compile("[a-zA-Z0-9_-]+\\.html");

    /**
     * 不安全的模板获取实现
     * 直接使用用户提供的模板名而不验证
     *
     * @param templateName 模板名称
     * @return 模板内容
     */
    public String getTemplateUnsafe(String templateName) {
        try {
            // 不安全：直接拼接模板路径而不验证
            File templateFile = new File(templateDir, templateName);
            return new String(Files.readAllBytes(templateFile.toPath()));
        } catch (IOException e) {
            return "Error loading template: " + e.getMessage();
        }
    }

    /**
     * 安全的模板获取实现
     * 验证模板名称并确保访问路径在预期目录内
     *
     * @param templateName 模板名称
     * @return 模板内容
     */
    public String getTemplateSafe(String templateName) {
        // 安全：白名单验证模板名称
        if (!SAFE_TEMPLATE_PATTERN.matcher(templateName).matches()) {
            throw new SecurityException("Invalid template name");
        }

        try {
            Path basePath = Paths.get(templateDir).toAbsolutePath().normalize();
            Path templatePath = basePath.resolve(templateName).normalize();

            // 验证模板路径是否在预期目录内
            if (!templatePath.startsWith(basePath)) {
                throw new SecurityException("Access to the template is not allowed");
            }

            if (!Files.isRegularFile(templatePath)) {
                throw new IOException("Template not found");
            }

            return new String(Files.readAllBytes(templatePath));
        } catch (IOException e) {
            return "Error loading template: " + e.getMessage();
        }
    }

    /**
     * 不安全的多级模板获取实现
     * 允许用户指定子目录路径
     *
     * @param templatePath 模板路径
     * @return 模板内容
     */
    public String getNestedTemplateUnsafe(String templatePath) {
        try {
            // 不安全：直接拼接模板路径而不验证，允许用户指定子目录
            File templateFile = new File(templateDir, templatePath);
            return new String(Files.readAllBytes(templateFile.toPath()));
        } catch (IOException e) {
            return "Error loading template: " + e.getMessage();
        }
    }

    /**
     * 安全的多级模板获取实现
     * 验证模板路径不包含路径遍历字符
     *
     * @param templatePath 模板路径
     * @return 模板内容
     */
    public String getNestedTemplateSafe(String templatePath) {
        // 安全：验证不包含路径遍历字符
        if (templatePath.contains("..")) {
            throw new SecurityException("Invalid template path");
        }

        try {
            Path basePath = Paths.get(templateDir).toAbsolutePath().normalize();
            Path templateFullPath = basePath.resolve(templatePath).normalize();

            // 验证模板路径是否在预期目录内
            if (!templateFullPath.startsWith(basePath)) {
                throw new SecurityException("Access to the template is not allowed");
            }

            if (!Files.isRegularFile(templateFullPath)) {
                throw new IOException("Template not found");
            }

            return new String(Files.readAllBytes(templateFullPath));
        } catch (IOException e) {
            return "Error loading template: " + e.getMessage();
        }
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/service/UserService.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/service/UserService.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/service/ZipService.java
{'id': 'gen-1742916118-KouHtffrjY0omXsLvG7S', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742916118, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.service;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\n/**\n * ZIP文件处理服务\n * 用于处理ZIP文件的解压和获取条目，包含不安全和安全的实现\n */\n@Service\npublic class ZipService {\n\n    // 原注解: @Value("${file.base.dir}")\n    private String baseDir = "./files"; // 默认值，确保编译通过\n\n    // 原注解: @Value("${zip.extract.dir}")\n    private String extractDir = "/tmp/extracts"; // 从建模数据中获取的值\n\n    /**\n     * 不安全的ZIP条目获取实现\n     * 从ZIP文件中获取条目但不验证路径\n     *\n     * @param zipFilePath ZIP文件路径\n     * @param entryName 条目名称\n     * @return 条目内容\n     */\n    public String getZipEntryUnsafe(String zipFilePath, String entryName) {\n        try {\n            // 不安全：直接使用用户提供的ZIP文件路径\n            ZipFile zipFile = new ZipFile(new File(baseDir, zipFilePath));\n            ZipEntry entry = zipFile.getEntry(entryName);\n\n            if (entry == null) {\n                return "Entry not found";\n            }\n\n            StringBuilder content = new StringBuilder();\n            try (InputStream is = zipFile.getInputStream(entry)) {\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = is.read(buffer)) > 0) {\n                    content.append(new String(buffer, 0, len));\n                }\n            }\n\n            zipFile.close();\n            return content.toString();\n        } catch (IOException e) {\n            return "Error reading ZIP entry: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 安全的ZIP条目获取实现\n     * 验证ZIP条目路径不包含路径遍历模式\n     *\n     * @param zipFilePath ZIP文件路径\n     * @param entryName 条目名称\n     * @return 条目内容\n     */\n    public String getZipEntrySafe(String zipFilePath, String entryName) {\n        try {\n            // 安全：规范化路径并验证\n            Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();\n            Path zipPath = basePath.resolve(zipFilePath).normalize();\n\n            // 验证ZIP文件路径是否在预期目录内\n            if (!zipPath.startsWith(basePath)) {\n                throw new SecurityException("Access to the ZIP file is not allowed");\n            }\n\n            if (!Files.isRegularFile(zipPath)) {\n                throw new IOException("ZIP file not found");\n            }\n\n            // 验证条目名称不包含路径遍历字符\n            if (entryName.contains("..")) {\n                throw new SecurityException("Invalid ZIP entry path");\n            }\n\n            ZipFile zipFile = new ZipFile(zipPath.toFile());\n            ZipEntry entry = zipFile.getEntry(entryName);\n\n            if (entry == null) {\n                zipFile.close();\n                return "Entry not found";\n            }\n\n            StringBuilder content = new StringBuilder();\n            try (InputStream is = zipFile.getInputStream(entry)) {\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = is.read(buffer)) > 0) {\n                    content.append(new String(buffer, 0, len));\n                }\n            }\n\n            zipFile.close();\n            return content.toString();\n        } catch (Exception e) {\n            return "Error reading ZIP entry: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 不安全的ZIP解压实现\n     * 解压缩ZIP文件但不验证条目路径\n     *\n     * @param zipFilePath ZIP文件路径\n     * @return 解压结果\n     */\n    public String extractZipUnsafe(String zipFilePath) {\n        try {\n            File zipFile = new File(baseDir, zipFilePath);\n            if (!zipFile.exists()) {\n                return "ZIP file not found";\n            }\n\n            ZipFile zip = new ZipFile(zipFile);\n\n            // 创建解压目录\n            File extractDirectory = new File(extractDir);\n            if (!extractDirectory.exists()) {\n                extractDirectory.mkdirs();\n            }\n\n            // 不安全：直接解压所有条目而不验证路径\n            zip.stream().forEach(entry -> {\n                try {\n                    File entryFile = new File(extractDirectory, entry.getName());\n\n                    if (entry.isDirectory()) {\n                        entryFile.mkdirs();\n                    } else {\n                        entryFile.getParentFile().mkdirs();\n\n                        try (InputStream is = zip.getInputStream(entry);\n                             FileOutputStream fos = new FileOutputStream(entryFile)) {\n                            byte[] buffer = new byte[1024];\n                            int len;\n                            while ((len = is.read(buffer)) > 0) {\n                                fos.write(buffer, 0, len);\n                            }\n                        }\n                    }\n                } catch (IOException e) {\n                    // 忽略单个条目的错误\n                }\n            });\n\n            zip.close();\n            return "ZIP file extracted successfully";\n        } catch (IOException e) {\n            return "Error extracting ZIP file: " + e.getMessage();\n        }\n    }\n\n    /**\n     * 安全的ZIP解压实现\n     * 验证每个条目的路径不包含路径遍历模式\n     *\n     * @param zipFilePath ZIP文件路径\n     * @return 解压结果\n     */\n    public String extractZipSafe(String zipFilePath) {\n        try {\n            // 安全：规范化路径并验证\n            Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();\n            Path zipPath = basePath.resolve(zipFilePath).normalize();\n\n            // 验证ZIP文件路径是否在预期目录内\n            if (!zipPath.startsWith(basePath)) {\n                throw new SecurityException("Access to the ZIP file is not allowed");\n            }\n\n            if (!Files.isRegularFile(zipPath)) {\n                throw new IOException("ZIP file not found");\n            }\n\n            ZipFile zip = new ZipFile(zipPath.toFile());\n\n            // 创建解压目录\n            Path extractDirPath = Paths.get(extractDir).toAbsolutePath().normalize();\n            if (!Files.exists(extractDirPath)) {\n                Files.createDirectories(extractDirPath);\n            }\n\n            // 安全：验证每个条目的路径不包含路径遍历模式\n            zip.stream().forEach(entry -> {\n                try {\n                    // 关键安全措施：规范化并验证条目路径\n                    Path entryPath = extractDirPath.resolve(entry.getName()).normalize();\n\n                    // 验证最终路径是否在解压目录内\n                    if (!entryPath.startsWith(extractDirPath)) {\n                        throw new SecurityException("ZIP entry is outside of the target directory: " + entry.getName());\n                    }\n\n                    if (entry.isDirectory()) {\n                        Files.createDirectories(entryPath);\n                    } else {\n                        Files.createDirectories(entryPath.getParent());\n\n                        try (InputStream is = zip.getInputStream(entry)) {\n                            Files.copy(is, entryPath);\n                        }\n                    }\n                } catch (Exception e) {\n                    // 记录错误但继续处理其他条目\n                    System.err.println("Error extracting entry " + entry.getName() + ": " + e.getMessage());\n                }\n            });\n\n            zip.close();\n            return "ZIP file extracted successfully";\n        } catch (Exception e) {\n            return "Error extracting ZIP file: " + e.getMessage();\n        }\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 10580, 'completion_tokens': 2162, 'total_tokens': 12742}}
-----------

package edu.thu.benchmark.annotated.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * ZIP文件处理服务
 * 用于处理ZIP文件的解压和获取条目，包含不安全和安全的实现
 */
@Service
public class ZipService {

    // 原注解: @Value("${file.base.dir}")
    private String baseDir = "./files"; // 默认值，确保编译通过

    // 原注解: @Value("${zip.extract.dir}")
    private String extractDir = "/tmp/extracts"; // 从建模数据中获取的值

    /**
     * 不安全的ZIP条目获取实现
     * 从ZIP文件中获取条目但不验证路径
     *
     * @param zipFilePath ZIP文件路径
     * @param entryName 条目名称
     * @return 条目内容
     */
    public String getZipEntryUnsafe(String zipFilePath, String entryName) {
        try {
            // 不安全：直接使用用户提供的ZIP文件路径
            ZipFile zipFile = new ZipFile(new File(baseDir, zipFilePath));
            ZipEntry entry = zipFile.getEntry(entryName);

            if (entry == null) {
                return "Entry not found";
            }

            StringBuilder content = new StringBuilder();
            try (InputStream is = zipFile.getInputStream(entry)) {
                byte[] buffer = new byte[1024];
                int len;
                while ((len = is.read(buffer)) > 0) {
                    content.append(new String(buffer, 0, len));
                }
            }

            zipFile.close();
            return content.toString();
        } catch (IOException e) {
            return "Error reading ZIP entry: " + e.getMessage();
        }
    }

    /**
     * 安全的ZIP条目获取实现
     * 验证ZIP条目路径不包含路径遍历模式
     *
     * @param zipFilePath ZIP文件路径
     * @param entryName 条目名称
     * @return 条目内容
     */
    public String getZipEntrySafe(String zipFilePath, String entryName) {
        try {
            // 安全：规范化路径并验证
            Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();
            Path zipPath = basePath.resolve(zipFilePath).normalize();

            // 验证ZIP文件路径是否在预期目录内
            if (!zipPath.startsWith(basePath)) {
                throw new SecurityException("Access to the ZIP file is not allowed");
            }

            if (!Files.isRegularFile(zipPath)) {
                throw new IOException("ZIP file not found");
            }

            // 验证条目名称不包含路径遍历字符
            if (entryName.contains("..")) {
                throw new SecurityException("Invalid ZIP entry path");
            }

            ZipFile zipFile = new ZipFile(zipPath.toFile());
            ZipEntry entry = zipFile.getEntry(entryName);

            if (entry == null) {
                zipFile.close();
                return "Entry not found";
            }

            StringBuilder content = new StringBuilder();
            try (InputStream is = zipFile.getInputStream(entry)) {
                byte[] buffer = new byte[1024];
                int len;
                while ((len = is.read(buffer)) > 0) {
                    content.append(new String(buffer, 0, len));
                }
            }

            zipFile.close();
            return content.toString();
        } catch (Exception e) {
            return "Error reading ZIP entry: " + e.getMessage();
        }
    }

    /**
     * 不安全的ZIP解压实现
     * 解压缩ZIP文件但不验证条目路径
     *
     * @param zipFilePath ZIP文件路径
     * @return 解压结果
     */
    public String extractZipUnsafe(String zipFilePath) {
        try {
            File zipFile = new File(baseDir, zipFilePath);
            if (!zipFile.exists()) {
                return "ZIP file not found";
            }

            ZipFile zip = new ZipFile(zipFile);

            // 创建解压目录
            File extractDirectory = new File(extractDir);
            if (!extractDirectory.exists()) {
                extractDirectory.mkdirs();
            }

            // 不安全：直接解压所有条目而不验证路径
            zip.stream().forEach(entry -> {
                try {
                    File entryFile = new File(extractDirectory, entry.getName());

                    if (entry.isDirectory()) {
                        entryFile.mkdirs();
                    } else {
                        entryFile.getParentFile().mkdirs();

                        try (InputStream is = zip.getInputStream(entry);
                             FileOutputStream fos = new FileOutputStream(entryFile)) {
                            byte[] buffer = new byte[1024];
                            int len;
                            while ((len = is.read(buffer)) > 0) {
                                fos.write(buffer, 0, len);
                            }
                        }
                    }
                } catch (IOException e) {
                    // 忽略单个条目的错误
                }
            });

            zip.close();
            return "ZIP file extracted successfully";
        } catch (IOException e) {
            return "Error extracting ZIP file: " + e.getMessage();
        }
    }

    /**
     * 安全的ZIP解压实现
     * 验证每个条目的路径不包含路径遍历模式
     *
     * @param zipFilePath ZIP文件路径
     * @return 解压结果
     */
    public String extractZipSafe(String zipFilePath) {
        try {
            // 安全：规范化路径并验证
            Path basePath = Paths.get(baseDir).toAbsolutePath().normalize();
            Path zipPath = basePath.resolve(zipFilePath).normalize();

            // 验证ZIP文件路径是否在预期目录内
            if (!zipPath.startsWith(basePath)) {
                throw new SecurityException("Access to the ZIP file is not allowed");
            }

            if (!Files.isRegularFile(zipPath)) {
                throw new IOException("ZIP file not found");
            }

            ZipFile zip = new ZipFile(zipPath.toFile());

            // 创建解压目录
            Path extractDirPath = Paths.get(extractDir).toAbsolutePath().normalize();
            if (!Files.exists(extractDirPath)) {
                Files.createDirectories(extractDirPath);
            }

            // 安全：验证每个条目的路径不包含路径遍历模式
            zip.stream().forEach(entry -> {
                try {
                    // 关键安全措施：规范化并验证条目路径
                    Path entryPath = extractDirPath.resolve(entry.getName()).normalize();

                    // 验证最终路径是否在解压目录内
                    if (!entryPath.startsWith(extractDirPath)) {
                        throw new SecurityException("ZIP entry is outside of the target directory: " + entry.getName());
                    }

                    if (entry.isDirectory()) {
                        Files.createDirectories(entryPath);
                    } else {
                        Files.createDirectories(entryPath.getParent());

                        try (InputStream is = zip.getInputStream(entry)) {
                            Files.copy(is, entryPath);
                        }
                    }
                } catch (Exception e) {
                    // 记录错误但继续处理其他条目
                    System.err.println("Error extracting entry " + entry.getName() + ": " + e.getMessage());
                }
            });

            zip.close();
            return "ZIP file extracted successfully";
        } catch (Exception e) {
            return "Error extracting ZIP file: " + e.getMessage();
        }
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/service/impl/FileServiceImpl.java
2025-03-25 23:22:25,457 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742916146-Kn47gTZ7b9c7Pd9I1L3a', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742916146, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.service.impl;\n\nimport edu.thu.benchmark.annotated.annotation.Vulnerability;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;\nimport edu.thu.benchmark.annotated.annotation.VulnerabilityType;\nimport edu.thu.benchmark.annotated.entity.FileInfo;\nimport edu.thu.benchmark.annotated.service.FileService;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n@Service\npublic class FileServiceImpl implements FileService {\n\n    // 原注解: @Value("${file.upload.dir}")\n    private String uploadDir = "./uploads";\n\n    private final Path rootLocation;\n    private final List<FileInfo> fileInfoList = new ArrayList<>();\n    private final AtomicInteger fileIdCounter = new AtomicInteger(1);\n\n    public FileServiceImpl(String uploadDir) {\n        this.uploadDir = uploadDir;\n        this.rootLocation = Paths.get(uploadDir);\n    }\n\n    @Override\n    public void init() throws IOException {\n        Files.createDirectories(rootLocation);\n    }\n\n    @Override\n    public FileInfo store(MultipartFile file) throws IOException {\n        if (file.isEmpty()) {\n            throw new IOException("无法存储空文件");\n        }\n\n        String filename = file.getOriginalFilename();\n        if (filename == null || filename.contains("..")) {\n            throw new IOException("存储文件失败，文件名无效");\n        }\n\n        // 创建文件路径\n        Path destinationFile = this.rootLocation.resolve(filename).normalize();\n\n        // 检查目标文件是否在uploadDir目录下（防止路径遍历）\n        if (!destinationFile.getParent().equals(this.rootLocation.normalize())) {\n            throw new IOException("无法存储文件到指定目录外");\n        }\n\n        // 保存文件\n        try (InputStream inputStream = file.getInputStream()) {\n            Files.copy(inputStream, destinationFile, StandardCopyOption.REPLACE_EXISTING);\n        }\n\n        // 创建文件信息对象\n        FileInfo fileInfo = new FileInfo(\n                filename,\n                destinationFile.toString(),\n                file.getContentType(),\n                file.getSize()\n        );\n        fileInfo.setId(fileIdCounter.getAndIncrement());\n        fileInfoList.add(fileInfo);\n\n        return fileInfo;\n    }\n\n    @Override\n    public Resource loadByFilename(String filename) {\n        try {\n            Path file = rootLocation.resolve(filename);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            } else {\n                return null;\n            }\n        } catch (MalformedURLException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public Resource loadById(Integer id) {\n        FileInfo fileInfo = fileInfoList.stream()\n                .filter(info -> info.getId().equals(id))\n                .findFirst()\n                .orElse(null);\n\n        if (fileInfo == null) {\n            return null;\n        }\n\n        try {\n            Path file = Paths.get(fileInfo.getFilepath());\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            } else {\n                return null;\n            }\n        } catch (MalformedURLException e) {\n            return null;\n        }\n    }\n\n    @Vulnerability(\n            type = VulnerabilityType.PATH_TRAVERSAL,\n            cwe = 22,\n            description = "此方法存在路径遍历漏洞，允许攻击者通过操纵path参数来读取服务器上任意路径的文件",\n            remediation = "应验证路径是否在预期的目录内，可以使用isPathSafe方法",\n            level = VulnerabilityLevel.CRITICAL,\n            isRealVulnerability = true\n    )\n    @Override\n    public Resource loadByPath(String path) {\n        try {\n            // 不安全的实现 - 路径遍历漏洞\n            Path file = Paths.get(path);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            } else {\n                return null;\n            }\n        } catch (MalformedURLException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public List<FileInfo> getAllFiles() {\n        return fileInfoList;\n    }\n\n    @Override\n    public boolean deleteFile(Integer id) {\n        FileInfo fileInfo = fileInfoList.stream()\n                .filter(info -> info.getId().equals(id))\n                .findFirst()\n                .orElse(null);\n\n        if (fileInfo == null) {\n            return false;\n        }\n\n        try {\n            Path file = Paths.get(fileInfo.getFilepath());\n            if (Files.deleteIfExists(file)) {\n                fileInfoList.remove(fileInfo);\n                return true;\n            }\n            return false;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public Path getFilePath(String filename) {\n        return rootLocation.resolve(filename);\n    }\n\n    @Override\n    public boolean isPathSafe(Path path) {\n        try {\n            Path normalizedPath = path.normalize();\n            Path normalizedRoot = rootLocation.normalize();\n\n            // 检查路径是否以根目录开头\n            return normalizedPath.startsWith(normalizedRoot);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    // 不安全的辅助方法 - 用于演示目的\n    public String readFileContentUnsafe(String path) throws IOException {\n        return new String(Files.readAllBytes(Paths.get(path)));\n    }\n\n    // 安全的辅助方法\n    public String readFileContentSafe(String filename) throws IOException {\n        Path filePath = getFilePath(filename).normalize();\n        if (!isPathSafe(filePath)) {\n            throw new IOException("访问被拒绝：无法访问指定目录外的文件");\n        }\n        return new String(Files.readAllBytes(filePath));\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 9605, 'completion_tokens': 1786, 'total_tokens': 11391}}
-----------

package edu.thu.benchmark.annotated.service.impl;

import edu.thu.benchmark.annotated.annotation.Vulnerability;
import edu.thu.benchmark.annotated.annotation.VulnerabilityLevel;
import edu.thu.benchmark.annotated.annotation.VulnerabilityType;
import edu.thu.benchmark.annotated.entity.FileInfo;
import edu.thu.benchmark.annotated.service.FileService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

@Service
public class FileServiceImpl implements FileService {

    // 原注解: @Value("${file.upload.dir}")
    private String uploadDir = "./uploads";

    private final Path rootLocation;
    private final List<FileInfo> fileInfoList = new ArrayList<>();
    private final AtomicInteger fileIdCounter = new AtomicInteger(1);

    public FileServiceImpl(String uploadDir) {
        this.uploadDir = uploadDir;
        this.rootLocation = Paths.get(uploadDir);
    }

    @Override
    public void init() throws IOException {
        Files.createDirectories(rootLocation);
    }

    @Override
    public FileInfo store(MultipartFile file) throws IOException {
        if (file.isEmpty()) {
            throw new IOException("无法存储空文件");
        }

        String filename = file.getOriginalFilename();
        if (filename == null || filename.contains("..")) {
            throw new IOException("存储文件失败，文件名无效");
        }

        // 创建文件路径
        Path destinationFile = this.rootLocation.resolve(filename).normalize();

        // 检查目标文件是否在uploadDir目录下（防止路径遍历）
        if (!destinationFile.getParent().equals(this.rootLocation.normalize())) {
            throw new IOException("无法存储文件到指定目录外");
        }

        // 保存文件
        try (InputStream inputStream = file.getInputStream()) {
            Files.copy(inputStream, destinationFile, StandardCopyOption.REPLACE_EXISTING);
        }

        // 创建文件信息对象
        FileInfo fileInfo = new FileInfo(
                filename,
                destinationFile.toString(),
                file.getContentType(),
                file.getSize()
        );
        fileInfo.setId(fileIdCounter.getAndIncrement());
        fileInfoList.add(fileInfo);

        return fileInfo;
    }

    @Override
    public Resource loadByFilename(String filename) {
        try {
            Path file = rootLocation.resolve(filename);
            Resource resource = new UrlResource(file.toUri());
            if (resource.exists() || resource.isReadable()) {
                return resource;
            } else {
                return null;
            }
        } catch (MalformedURLException e) {
            return null;
        }
    }

    @Override
    public Resource loadById(Integer id) {
        FileInfo fileInfo = fileInfoList.stream()
                .filter(info -> info.getId().equals(id))
                .findFirst()
                .orElse(null);

        if (fileInfo == null) {
            return null;
        }

        try {
            Path file = Paths.get(fileInfo.getFilepath());
            Resource resource = new UrlResource(file.toUri());
            if (resource.exists() || resource.isReadable()) {
                return resource;
            } else {
                return null;
            }
        } catch (MalformedURLException e) {
            return null;
        }
    }

    @Vulnerability(
            type = VulnerabilityType.PATH_TRAVERSAL,
            cwe = 22,
            description = "此方法存在路径遍历漏洞，允许攻击者通过操纵path参数来读取服务器上任意路径的文件",
            remediation = "应验证路径是否在预期的目录内，可以使用isPathSafe方法",
            level = VulnerabilityLevel.CRITICAL,
            isRealVulnerability = true
    )
    @Override
    public Resource loadByPath(String path) {
        try {
            // 不安全的实现 - 路径遍历漏洞
            Path file = Paths.get(path);
            Resource resource = new UrlResource(file.toUri());
            if (resource.exists() || resource.isReadable()) {
                return resource;
            } else {
                return null;
            }
        } catch (MalformedURLException e) {
            return null;
        }
    }

    @Override
    public List<FileInfo> getAllFiles() {
        return fileInfoList;
    }

    @Override
    public boolean deleteFile(Integer id) {
        FileInfo fileInfo = fileInfoList.stream()
                .filter(info -> info.getId().equals(id))
                .findFirst()
                .orElse(null);

        if (fileInfo == null) {
            return false;
        }

        try {
            Path file = Paths.get(fileInfo.getFilepath());
            if (Files.deleteIfExists(file)) {
                fileInfoList.remove(fileInfo);
                return true;
            }
            return false;
        } catch (IOException e) {
            return false;
        }
    }

    @Override
    public Path getFilePath(String filename) {
        return rootLocation.resolve(filename);
    }

    @Override
    public boolean isPathSafe(Path path) {
        try {
            Path normalizedPath = path.normalize();
            Path normalizedRoot = rootLocation.normalize();

            // 检查路径是否以根目录开头
            return normalizedPath.startsWith(normalizedRoot);
        } catch (Exception e) {
            return false;
        }
    }

    // 不安全的辅助方法 - 用于演示目的
    public String readFileContentUnsafe(String path) throws IOException {
        return new String(Files.readAllBytes(Paths.get(path)));
    }

    // 安全的辅助方法
    public String readFileContentSafe(String filename) throws IOException {
        Path filePath = getFilePath(filename).normalize();
        if (!isPathSafe(filePath)) {
            throw new IOException("访问被拒绝：无法访问指定目录外的文件");
        }
        return new String(Files.readAllBytes(filePath));
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/service/impl/UserServiceImpl.java
2025-03-25 23:22:53,486 - llm_client - INFO - LLM客户端初始化完成，使用模型: anthropic/claude-3.7-sonnet
{'id': 'gen-1742916174-CJmytzONqvwGk4j5oq0h', 'provider': 'Google', 'model': 'anthropic/claude-3.7-sonnet', 'object': 'chat.completion', 'created': 1742916174, 'choices': [{'logprobs': None, 'finish_reason': 'stop', 'native_finish_reason': 'stop', 'index': 0, 'message': {'role': 'assistant', 'content': 'package edu.thu.benchmark.annotated.service.impl;\n\nimport edu.thu.benchmark.annotated.entity.User;\nimport edu.thu.benchmark.annotated.mapper.UserMapper;\nimport edu.thu.benchmark.annotated.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * 用户服务实现类\n */\n@Service\npublic class UserServiceImpl implements UserService {\n\n    // 原注解: @Autowired\n    // 注意：userMapper是Mybatis的接口，不能直接实例化，保留原样\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public User getUserById(Integer id) {\n        return userMapper.getUserById(id);\n    }\n\n    @Override\n    public User getUserByUsername(String username) {\n        return userMapper.getUserByUsername(username);\n    }\n\n    @Override\n    public User getUserByEmail(String email) {\n        return userMapper.getUserByEmail(email);\n    }\n\n    @Override\n    public List<User> getAllUsers() {\n        return userMapper.getAllUsers();\n    }\n\n    @Override\n    public List<User> findUsersByCondition(String condition) {\n        return userMapper.findUsersByCondition(condition);\n    }\n\n    @Override\n    public int insertUser(User user) {\n        return userMapper.insertUser(user);\n    }\n\n    @Override\n    public int updateUser(Integer id, String updateFields) {\n        return userMapper.updateUser(id, updateFields);\n    }\n\n    @Override\n    public int deleteUser(Integer id) {\n        return userMapper.deleteUser(id);\n    }\n}', 'refusal': None, 'reasoning': None}}], 'usage': {'prompt_tokens': 7362, 'completion_tokens': 435, 'total_tokens': 7797}}
-----------

package edu.thu.benchmark.annotated.service.impl;

import edu.thu.benchmark.annotated.entity.User;
import edu.thu.benchmark.annotated.mapper.UserMapper;
import edu.thu.benchmark.annotated.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 用户服务实现类
 */
@Service
public class UserServiceImpl implements UserService {

    // 原注解: @Autowired
    // 注意：userMapper是Mybatis的接口，不能直接实例化，保留原样
    @Autowired
    private UserMapper userMapper;

    @Override
    public User getUserById(Integer id) {
        return userMapper.getUserById(id);
    }

    @Override
    public User getUserByUsername(String username) {
        return userMapper.getUserByUsername(username);
    }

    @Override
    public User getUserByEmail(String email) {
        return userMapper.getUserByEmail(email);
    }

    @Override
    public List<User> getAllUsers() {
        return userMapper.getAllUsers();
    }

    @Override
    public List<User> findUsersByCondition(String condition) {
        return userMapper.findUsersByCondition(condition);
    }

    @Override
    public int insertUser(User user) {
        return userMapper.insertUser(user);
    }

    @Override
    public int updateUser(Integer id, String updateFields) {
        return userMapper.updateUser(id, updateFields);
    }

    @Override
    public int deleteUser(Integer id) {
        return userMapper.deleteUser(id);
    }
}

处理文件: src/main/java/edu/thu/benchmark/annotated/util/CommandUtils.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/util/CommandUtils.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/util/FileUtils.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/util/FileUtils.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/util/MyBatisCompiler.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/util/MyBatisCompiler.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/util/MyBatisMapperScanner.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/util/MyBatisMapperScanner.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/util/MyBatisSqlExtractor.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/util/MyBatisSqlExtractor.java. 跳过

处理文件: src/main/java/edu/thu/benchmark/annotated/util/MyBatisXmlParser.java

无需处理处理: src/main/java/edu/thu/benchmark/annotated/util/MyBatisXmlParser.java. 跳过


Ran 1 test in 597.725s

OK

Process finished with exit code 0
